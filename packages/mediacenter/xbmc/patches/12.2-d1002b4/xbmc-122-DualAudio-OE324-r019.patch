From 138d6bd855d9af79162b73d083ce4a7b72eea374 Mon Sep 17 00:00:00 2001
From: xhbl <newxhbl@hotmail.com>
Date: Fri, 11 Apr 2014 11:11:11 +0800
Subject: [PATCH] [DualAudio] GUI Sounds/Video dvdplayer/Music paplayer 2nd Output supported

---
 xbmc/Application.cpp                               |   1 +
 xbmc/GUIInfoManager.h                              |   2 +-
 xbmc/cores/AudioEngine/AEFactory.cpp               | 151 +++++++++--
 xbmc/cores/AudioEngine/AEFactory.h                 |  19 +-
 xbmc/cores/AudioEngine/AESinkFactory.cpp           |   3 +
 .../cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp |   4 +-
 .../AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp  |  51 +++-
 .../AudioEngine/Engines/CoreAudio/CoreAudioAE.h    |   2 +
 .../Engines/CoreAudio/CoreAudioAEHALOSX.cpp        |   5 +-
 .../Engines/CoreAudio/CoreAudioAESound.cpp         |   3 +-
 .../Engines/CoreAudio/CoreAudioAEStream.cpp        |   6 +-
 .../Engines/CoreAudio/ICoreAudioAEHAL.h            |   5 +-
 xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp |   4 +
 xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h   |   2 +
 .../AudioEngine/Engines/PulseAE/PulseAESound.cpp   |   3 +-
 .../AudioEngine/Engines/PulseAE/PulseAEStream.cpp  |   2 +-
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp   | 112 ++++++++-
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h     |   6 +
 .../AudioEngine/Engines/SoftAE/SoftAESound.cpp     |   3 +-
 .../AudioEngine/Engines/SoftAE/SoftAEStream.cpp    |   6 +-
 xbmc/cores/AudioEngine/Interfaces/AE.h             |  12 +-
 xbmc/cores/AudioEngine/Interfaces/AEEncoder.h      |   7 +-
 xbmc/cores/AudioEngine/Interfaces/AESound.h        |   6 +-
 xbmc/cores/AudioEngine/Interfaces/AEStream.h       |   7 +-
 xbmc/cores/AudioEngine/Utils/AERemap.cpp           |   5 +-
 xbmc/cores/AudioEngine/Utils/AERemap.h             |   3 +
 xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp       |   2 +
 xbmc/cores/AudioEngine/Utils/AEWAVLoader.h         |   4 +
 xbmc/cores/dvdplayer/DVDAudio.cpp                  |   6 +-
 xbmc/cores/dvdplayer/DVDAudio.h                    |   3 +-
 .../dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h      |   8 +-
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp        |   4 +-
 .../DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp   |  12 +-
 .../Audio/DVDAudioCodecPassthroughFFmpeg.cpp       |   8 +-
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |  17 +-
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h   |   4 +-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp |  18 ++
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h   |   1 +
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp            | 260 +++++++++++++++++--
 xbmc/cores/dvdplayer/DVDPlayerAudio.h              |  76 +++++-
 xbmc/cores/paplayer/AudioDecoder.cpp               |   8 +
 xbmc/cores/paplayer/AudioDecoder.h                 |   6 +
 xbmc/cores/paplayer/DVDPlayerCodec.cpp             |  17 +-
 xbmc/cores/paplayer/ICodec.h                       |  11 +
 xbmc/cores/paplayer/PAPlayer.cpp                   | 280 ++++++++++++++++++++-
 xbmc/cores/paplayer/PAPlayer.h                     |  16 ++
 xbmc/guilib/GUIAudioManager.cpp                    |  98 ++++++--
 xbmc/guilib/GUIAudioManager.h                      |  20 +-
 xbmc/settings/GUISettings.cpp                      |  76 ++++++
 xbmc/settings/GUISettings.h                        |   1 +
 xbmc/settings/GUIWindowSettingsCategory.cpp        |  86 ++++++-
 xbmc/settings/GUIWindowSettingsCategory.h          |   2 +-
 52 files changed, 1330 insertions(+), 144 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 848d981..f702d32 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -745,6 +745,7 @@ bool CApplication::Create()
   SetHardwareVolume(g_settings.m_fVolumeLevel);
   CAEFactory::SetMute     (g_settings.m_bMute);
   CAEFactory::SetSoundMode(g_guiSettings.GetInt("audiooutput.guisoundmode"));
+  CAEFactory::SetSoundMode(g_guiSettings.GetInt("audiooutput2.guisoundmode"),true);
 
   // initialize the addon database (must be before the addon manager is init'd)
   CDatabaseManager::Get().Initialize(true);
diff --git a/xbmc/GUIInfoManager.h b/xbmc/GUIInfoManager.h
index 6d8b70f..f0b6b99 100644
--- a/xbmc/GUIInfoManager.h
+++ b/xbmc/GUIInfoManager.h
@@ -504,7 +504,7 @@ namespace INFO
 
 #define VERSION_MAJOR 12
 #define VERSION_MINOR 2
-#define VERSION_TAG ""
+#define VERSION_TAG "-DualAudio-r019"
 
 #define LISTITEM_START              35000
 #define LISTITEM_THUMB              (LISTITEM_START)
diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 86392c1..dee1b79 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -32,12 +32,16 @@
 #endif
 
 IAE* CAEFactory::AE = NULL;
+IAE* CAEFactory::AE2 = NULL;
 static float  g_fVolume = 1.0f;
 static bool   g_bMute = false;
 
-IAE *CAEFactory::GetEngine()
+IAE *CAEFactory::GetEngine(bool bAudio2)
 {
-  return AE;
+  if(!bAudio2)
+    return AE;
+  else
+    return AE2;
 }
 
 bool CAEFactory::LoadEngine()
@@ -109,6 +113,32 @@ bool CAEFactory::LoadEngine(enum AEEngine engine)
     AE = NULL;
   }
 
+  if (!AE2)
+  {
+    switch(engine)
+    {
+      case AE_ENGINE_NULL	  :
+#if defined(TARGET_DARWIN)
+      case AE_ENGINE_COREAUDIO: AE2 = new CCoreAudioAE(); break;
+#else
+      case AE_ENGINE_SOFT	  : AE2 = new CSoftAE(); break;
+#endif
+#if defined(HAS_PULSEAUDIO)
+      case AE_ENGINE_PULSE	  : AE2 = new CPulseAE(); break;
+#endif
+  
+      default: break;
+    }
+  
+    if (AE2)
+        AE2->SetAudio2(true);
+    if (AE2 && !AE2->CanInit())
+    {
+      delete AE2;
+      AE2 = NULL;
+    }
+  }
+
   return AE != NULL;
 }
 
@@ -120,6 +150,12 @@ void CAEFactory::UnLoadEngine()
     delete AE;
     AE = NULL;
   }
+  if(AE2)
+  {
+    AE2->Shutdown();
+    delete AE2;
+    AE2 = NULL;
+  }
 }
 
 bool CAEFactory::StartEngine()
@@ -132,7 +168,17 @@ bool CAEFactory::StartEngine()
     return false;
 
   if (AE->Initialize())
+  {
+    if (AE2)
+    {
+      if(!AE2->Initialize())
+      {
+        delete AE2;
+        AE2 = NULL;
+      }
+    }
     return true;
+  }
 
   delete AE;
   AE = NULL;
@@ -141,18 +187,24 @@ bool CAEFactory::StartEngine()
 
 bool CAEFactory::Suspend()
 {
+  bool bRet = false;
   if(AE)
-    return AE->Suspend();
+    bRet = AE->Suspend();
+  if (AE2)
+    AE2->Suspend();
 
-  return false;
+  return bRet;
 }
 
 bool CAEFactory::Resume()
 {
+  bool bRet = false;
   if(AE)
-    return AE->Resume();
+    bRet = AE->Resume();
+  if (AE2)
+    AE2->Resume();
 
-  return false;
+  return bRet;
 }
 
 bool CAEFactory::IsSuspended()
@@ -165,36 +217,50 @@ bool CAEFactory::IsSuspended()
 }
 
 /* engine wrapping */
-IAESound *CAEFactory::MakeSound(const std::string &file)
+IAESound *CAEFactory::MakeSound(const std::string &file, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     return AE->MakeSound(file);
+  if(bAudio2 && AE2)
+    return AE2->MakeSound(file);
   
   return NULL;
 }
 
 void CAEFactory::FreeSound(IAESound *sound)
 {
-  if(AE)
+  if(!sound)
+    return;
+  bool bAudio2 = sound->IsAudio2();
+
+  if(!bAudio2 && AE)
     AE->FreeSound(sound);
+  if(bAudio2 && AE2)
+    AE2->FreeSound(sound);
 }
 
-void CAEFactory::SetSoundMode(const int mode)
+void CAEFactory::SetSoundMode(const int mode, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     AE->SetSoundMode(mode);
+  if(bAudio2 && AE2)
+    AE2->SetSoundMode(mode);
 }
 
-void CAEFactory::OnSettingsChange(std::string setting)
+void CAEFactory::OnSettingsChange(std::string setting, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     AE->OnSettingsChange(setting);
+  if(bAudio2 && AE2)
+    AE2->OnSettingsChange(setting);
 }
 
-void CAEFactory::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough)
+void CAEFactory::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     AE->EnumerateOutputDevices(devices, passthrough);
+  if(bAudio2 && AE2)
+    AE2->EnumerateOutputDevices(devices, passthrough);
 }
 
 void CAEFactory::VerifyOutputDevice(std::string &device, bool passthrough)
@@ -223,18 +289,32 @@ void CAEFactory::VerifyOutputDevice(std::string &device, bool passthrough)
   device = firstDevice;
 }
 
-std::string CAEFactory::GetDefaultDevice(bool passthrough)
+std::string CAEFactory::GetDefaultDevice(bool passthrough, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     return AE->GetDefaultDevice(passthrough);
+  if(bAudio2 && AE2)
+    return AE2->GetDefaultDevice(passthrough);
 
   return "default";
 }
 
-bool CAEFactory::SupportsRaw()
+std::string CAEFactory::GetCreateDevice(bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
+    return AE->GetCreateDevice();
+  if(bAudio2 && AE2)
+    return AE2->GetCreateDevice();
+
+  return "";
+}
+
+bool CAEFactory::SupportsRaw(bool bAudio2)
+{
+  if(!bAudio2 && AE)
     return AE->SupportsRaw();
+  if(bAudio2 && AE2)
+    return AE2->SupportsRaw();
 
   return false;
 }
@@ -243,6 +323,8 @@ void CAEFactory::SetMute(const bool enabled)
 {
   if(AE)
     AE->SetMute(enabled);
+  if(AE2)
+    AE2->SetMute(enabled);
 
   g_bMute = enabled;
 }
@@ -255,6 +337,16 @@ bool CAEFactory::IsMuted()
   return g_bMute || (g_fVolume == 0.0f);
 }
 
+bool CAEFactory::IsDumb(bool bAudio2)
+{
+  if(!bAudio2 && AE)
+    return AE->IsDumb();
+  if(bAudio2 && AE2)
+    return AE2->IsDumb();
+
+  return true;
+}
+
 float CAEFactory::GetVolume()
 {
   if(AE)
@@ -266,7 +358,10 @@ float CAEFactory::GetVolume()
 void CAEFactory::SetVolume(const float volume)
 {
   if(AE)
+  {
     AE->SetVolume(volume);
+    AE2->SetVolume(volume);
+  }
   else
     g_fVolume = volume;
 }
@@ -275,21 +370,31 @@ void CAEFactory::Shutdown()
 {
   if(AE)
     AE->Shutdown();
+  if(AE2)
+    AE2->Shutdown();
 }
 
 IAEStream *CAEFactory::MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, 
-  unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options)
+  unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options, bool bAudio2)
 {
-  if(AE)
+  if(!bAudio2 && AE)
     return AE->MakeStream(dataFormat, sampleRate, encodedSampleRate, channelLayout, options);
+  if(bAudio2 && AE2)
+    return AE2->MakeStream(dataFormat, sampleRate, encodedSampleRate, channelLayout, options);
 
   return NULL;
 }
 
 IAEStream *CAEFactory::FreeStream(IAEStream *stream)
 {
-  if(AE)
+  if(!stream)
+    return NULL;
+  bool bAudio2 = stream->IsAudio2();
+
+  if(!bAudio2 && AE)
     return AE->FreeStream(stream);
+  if(bAudio2 && AE2)
+    return AE2->FreeStream(stream);
 
   return NULL;
 }
@@ -298,4 +403,6 @@ void CAEFactory::GarbageCollect()
 {
   if(AE)
     AE->GarbageCollect();
+  if(AE2)
+    AE2->GarbageCollect();
 }
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index 3c296ef..c829248 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -33,7 +33,7 @@ enum AEEngine
 class CAEFactory
 {
 public:
-  static IAE *GetEngine();
+  static IAE *GetEngine(bool bAudio2 = false);
   static bool LoadEngine();
   static void UnLoadEngine();
   static bool StartEngine();
@@ -41,25 +41,28 @@ public:
   static bool Resume(); /** Resumes output after Suspend - re-initializes sink */
   static bool IsSuspended(); /** Returns true if output has been suspended */
   /* wrap engine interface */
-  static IAESound *MakeSound(const std::string &file);
+  static IAESound *MakeSound(const std::string &file, bool bAudio2 = false);
   static void FreeSound(IAESound *sound);
-  static void SetSoundMode(const int mode);
-  static void OnSettingsChange(std::string setting);
-  static void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
+  static void SetSoundMode(const int mode, bool bAudio2 = false);
+  static void OnSettingsChange(std::string setting, bool bAudio2 = false);
+  static void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough, bool bAudio2 = false);
   static void VerifyOutputDevice(std::string &device, bool passthrough);
-  static std::string GetDefaultDevice(bool passthrough);
-  static bool SupportsRaw();
+  static std::string GetDefaultDevice(bool passthrough, bool bAudio2 = false);
+  static std::string GetCreateDevice(bool bAudio2 = false);
+  static bool SupportsRaw(bool bAudio2 = false);
   static void SetMute(const bool enabled);
   static bool IsMuted();
+  static bool IsDumb(bool bAudio2 = false);
   static float GetVolume();
   static void SetVolume(const float volume);
   static void Shutdown();
   static IAEStream *MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, 
-    unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options = 0);
+    unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options = 0, bool bAudio2 = false);
   static IAEStream *FreeStream(IAEStream *stream);
   static void GarbageCollect();
 private:
   static bool LoadEngine(enum AEEngine engine);
   static IAE *AE;
+  static IAE *AE2;
 };
 
diff --git a/xbmc/cores/AudioEngine/AESinkFactory.cpp b/xbmc/cores/AudioEngine/AESinkFactory.cpp
index b5bd692..78b392a 100644
--- a/xbmc/cores/AudioEngine/AESinkFactory.cpp
+++ b/xbmc/cores/AudioEngine/AESinkFactory.cpp
@@ -96,6 +96,9 @@ IAESink *CAESinkFactory::Create(std::string &device, AEAudioFormat &desiredForma
   IAESink       *sink;
   std::string    tmpDevice;
 
+  if (device == "NULL")
+    TRY_SINK(NULL);
+
   if (driver == "PROFILER")
     TRY_SINK(Profiler);
 
diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
index d6463b3..316f3dd 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
@@ -100,12 +100,12 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
 
   m_dllAvCodec.avcodec_register_all();
 
-  bool ac3 = g_guiSettings.GetBool("audiooutput.ac3passthrough");
+  bool ac3 = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.ac3passthrough" : "audiooutput2.ac3passthrough");
 
   AVCodec *codec = NULL;
 #if 0
   /* the DCA encoder is currently useless for transcode, it creates a 196 kHz DTS-HD like mongrel which is useless for SPDIF */
-  bool dts = g_guiSettings.GetBool("audiooutput.dtspassthrough");
+  bool dts = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.dtspassthrough" : "audiooutput2.dtspassthrough");
   if (dts && (!ac3 || g_advancedSettings.m_audioTranscodeTo.Equals("dts")))
   {
     m_CodecName = "DTS";
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
index 56fc3d2..3157e93 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
@@ -156,6 +156,8 @@ void CCoreAudioAE::AudioDevicesChanged()
 bool CCoreAudioAE::Initialize()
 {
   CSingleLock engineLock(m_engineLock);
+  if(m_bAudio2)
+    SetDisabled(g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE);
 
   Stop();
 
@@ -206,12 +208,13 @@ bool CCoreAudioAE::OpenCoreAudio(unsigned int sampleRate, bool forceRaw,
   if (m_rawPassthrough)
     CLog::Log(LOGINFO, "CCoreAudioAE::OpenCoreAudio - RAW passthrough enabled");
 
-  std::string m_outputDevice =  g_guiSettings.GetString("audiooutput.audiodevice");
+  std::string m_outputDevice =  g_guiSettings.GetString(!m_bAudio2 ? "audiooutput.audiodevice" : "audiooutput2.audiodevice");
 
   // on iOS devices we set fixed to two channels.
   m_stdChLayout = AE_CH_LAYOUT_2_0;
 #if defined(TARGET_DARWIN_OSX)
-  switch (g_guiSettings.GetInt("audiooutput.channels"))
+  int ao_channels = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.channels" : "audiooutput2.channels");
+  switch (ao_channels)
   {
     default:
     case  0: m_stdChLayout = AE_CH_LAYOUT_2_0; break; /* do not allow 1_0 output */
@@ -228,7 +231,8 @@ bool CCoreAudioAE::OpenCoreAudio(unsigned int sampleRate, bool forceRaw,
   }
 #endif
   // force optical/coax to 2.0 output channels
-  if (!m_rawPassthrough && g_guiSettings.GetInt("audiooutput.mode") == AUDIO_IEC958)
+  int ao_mode = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode");
+  if (!m_rawPassthrough && ao_mode == AUDIO_IEC958)
     m_stdChLayout = AE_CH_LAYOUT_2_0;
 
   // setup the desired format
@@ -286,6 +290,7 @@ bool CCoreAudioAE::OpenCoreAudio(unsigned int sampleRate, bool forceRaw,
   AEAudioFormat initformat = m_format;
 
   // initialize audio hardware
+  HAL->SetAudio2(m_bAudio2);
   m_Initialized = HAL->Initialize(this, m_rawPassthrough, initformat, rawDataFormat, m_outputDevice, m_volume);
 
   unsigned int bps         = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
@@ -363,6 +368,9 @@ void CCoreAudioAE::Deinitialize()
 
 void CCoreAudioAE::OnSettingsChange(const std::string& setting)
 {
+  if(m_bAudio2)
+    return OnSettingsChange2(setting);
+	
   if (setting == "audiooutput.dontnormalizelevels")
   {
     // re-init streams remapper
@@ -390,6 +398,36 @@ void CCoreAudioAE::OnSettingsChange(const std::string& setting)
   }
 }
 
+void CCoreAudioAE::OnSettingsChange2(const std::string& setting)
+{
+  SetDisabled(g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE);
+  if (setting == "audiooutput2.dontnormalizelevels")
+  {
+    // re-init streams remapper
+    CSingleLock streamLock(m_streamLock);
+    for (StreamList::iterator itt = m_streams.begin(); itt != m_streams.end(); ++itt)
+      (*itt)->InitializeRemap();
+    streamLock.Leave();
+  }
+
+  if (setting == "audiooutput2.passthroughdevice" ||
+      setting == "audiooutput2.custompassthrough" ||
+      setting == "audiooutput2.audiodevice"       ||
+      setting == "audiooutput2.customdevice"      ||
+      setting == "audiooutput2.mode"              ||
+      setting == "audiooutput2.ac3passthrough"    ||
+      setting == "audiooutput2.dtspassthrough"    ||
+      setting == "audiooutput2.channels"     ||
+      setting == "audiooutput2.multichannellpcm")
+  {
+    // only reinit the engine if we not
+    // suspended (resume will initialize
+    // us again in that case)
+    if (!m_isSuspended)
+      Initialize();
+  }
+}
+
 unsigned int CCoreAudioAE::GetSampleRate()
 {
   return m_format.m_sampleRate;
@@ -464,6 +502,11 @@ bool CCoreAudioAE::IsMuted()
   return m_muted;
 }
 
+bool CCoreAudioAE::IsDumb()
+{
+  return IsDisabled() || !m_Initialized;
+}
+
 bool CCoreAudioAE::IsSuspended()
 {
   return m_isSuspended;
@@ -501,6 +544,7 @@ IAEStream* CCoreAudioAE::MakeStream(enum AEDataFormat dataFormat,
     CAEUtil::DataFormatToStr(dataFormat), sampleRate, encodedSamplerate, ((std::string)channelInfo).c_str());
 
   CCoreAudioAEStream *stream = new CCoreAudioAEStream(dataFormat, sampleRate, encodedSamplerate, channelLayout, options);
+  stream->SetAudio2(m_bAudio2);
   CSingleLock streamLock(m_streamLock);
   m_streams.push_back(stream);
   streamLock.Leave();
@@ -624,6 +668,7 @@ IAESound *CCoreAudioAE::MakeSound(const std::string& file)
   }
 
   CCoreAudioAESound *sound = new CCoreAudioAESound(file);
+  sound->SetAudio2(m_bAudio2);
   if (!sound->Initialize())
   {
     delete sound;
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
index 3ddf25d..1d2dc8a 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
@@ -90,6 +90,7 @@ public:
   virtual void      SetVolume(float volume);
   virtual void      SetMute(const bool enabled);
   virtual bool      IsMuted();
+  virtual bool      IsDumb();
   virtual void      SetSoundMode(const int mode);
 
 
@@ -167,6 +168,7 @@ private:
   OSStatus          OnRender(AudioUnitRenderActionFlags *actionFlags,
                       const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber,
                       UInt32 inNumberFrames, AudioBufferList *ioData);
+  void              OnSettingsChange2(const std::string& setting);
 
   float             m_volume;
   float             m_volumeBeforeMute;
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
index ca8e0e4..daddb7c 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEHALOSX.cpp
@@ -93,9 +93,10 @@ bool CCoreAudioAEHALOSX::InitializePCM(ICoreAudioSource *pSource, AEAudioFormat
   if (!m_audioGraph)
     return false;
 
-  AudioChannelLayoutTag layout = g_LayoutMap[ g_guiSettings.GetInt("audiooutput.channels") ];
+  AudioChannelLayoutTag layout = g_LayoutMap[ g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.channels" : "audiooutput2.channels") ];
   // force optical/coax to 2.0 output channels
-  if (!m_Passthrough && g_guiSettings.GetInt("audiooutput.mode") == AUDIO_IEC958)
+  int ao_mode = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode");
+  if (!m_Passthrough && ao_mode == AUDIO_IEC958)
     layout = g_LayoutMap[1];
 
   if (!m_audioGraph->Open(pSource, format, outputDevice, allowMixing, layout, m_initVolume ))
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp
index 8c49417..906663e 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAESound.cpp
@@ -34,7 +34,7 @@
 #include "utils/EndianSwap.h"
 
 /* typecast AE to CCoreAudioAE */
-#define AE (*(CCoreAudioAE*)CAEFactory::GetEngine())
+#define AE (*(CCoreAudioAE*)CAEFactory::GetEngine(m_bAudio2))
 
 CCoreAudioAESound::CCoreAudioAESound(const std::string &filename) :
   IAESound         (filename),
@@ -64,6 +64,7 @@ bool CCoreAudioAESound::Initialize()
 {
   if (!m_wavLoader.IsValid())
     return false;
+  m_wavLoader.SetAudio2(m_bAudio2);
 
   return m_wavLoader.Initialize(
     AE.GetSampleRate   (),
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
index 85e84d5..3090c5e 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
@@ -36,7 +36,7 @@
 
 
 // typecast AE to CCoreAudioAE
-#define AE (*(CCoreAudioAE*)CAEFactory::GetEngine())
+#define AE (*(CCoreAudioAE*)CAEFactory::GetEngine(m_bAudio2))
 
 void CheckOutputBufferSize(void **buffer, int *oldSize, int newSize)
 {
@@ -175,6 +175,8 @@ void CCoreAudioAEStream::InitializeRemap()
       m_OutputBytesPerSample    = (CAEUtil::DataFormatToBits(m_OutputFormat.m_dataFormat) >> 3);
 
       // re-init the remappers
+      m_remap.SetAudio2(m_bAudio2);
+      m_vizRemap.SetAudio2(m_bAudio2);
       m_remap   .Initialize(m_StreamFormat.m_channelLayout, m_OutputFormat.m_channelLayout, false);
       m_vizRemap.Initialize(m_StreamFormat.m_channelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
 
@@ -259,6 +261,7 @@ void CCoreAudioAEStream::Initialize()
 
   if (!m_isRaw)
   {
+    m_remap.SetAudio2(m_bAudio2);
     if (!m_remap.Initialize(m_StreamFormat.m_channelLayout, m_OutputFormat.m_channelLayout, false))
     {
       m_valid = false;
@@ -270,6 +273,7 @@ void CCoreAudioAEStream::Initialize()
 
   if (!m_isRaw)
   {
+    m_vizRemap.SetAudio2(m_bAudio2);
     if (!m_vizRemap.Initialize(m_OutputFormat.m_channelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true))
     {
       m_valid = false;
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h b/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h
index 66087b3..9dffa87 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/ICoreAudioAEHAL.h
@@ -32,7 +32,8 @@ class CAUOutputDevice;
 class ICoreAudioAEHAL
 {
 protected:
-  ICoreAudioAEHAL() {}
+  bool m_bAudio2;
+  ICoreAudioAEHAL() { m_bAudio2 = false; }
   virtual ~ICoreAudioAEHAL() {}
 
 public:
@@ -46,4 +47,6 @@ public:
   virtual bool   Start() = 0;
   virtual double GetDelay() = 0;
   virtual void   SetVolume(float volume) = 0;
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
 };
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp
index 79fbb36..36e0670 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.cpp
@@ -82,6 +82,7 @@ CPulseAE::CPulseAE()
   m_MainLoop = NULL;
   m_muted = false;
   m_Volume = 0.0f;
+  m_bDumb = true;
 }
 
 CPulseAE::~CPulseAE()
@@ -172,6 +173,7 @@ bool CPulseAE::Initialize()
   }
 
   pa_threaded_mainloop_unlock(m_MainLoop);
+  m_bDumb = false;
   return true;
 }
 
@@ -218,6 +220,7 @@ void CPulseAE::SetVolume(float volume)
 IAEStream *CPulseAE::MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate,CAEChannelInfo channelLayout, unsigned int options)
 {
   CPulseAEStream *st = new CPulseAEStream(m_Context, m_MainLoop, dataFormat, sampleRate, channelLayout, options);
+  st->SetAudio2(m_bAudio2);
 
   CSingleLock lock(m_lock);
   m_streams.push_back(st);
@@ -257,6 +260,7 @@ IAESound *CPulseAE::MakeSound(const std::string& file)
   CSingleLock lock(m_lock);
 
   CPulseAESound *sound = new CPulseAESound(file, m_Context, m_MainLoop);
+  sound->SetAudio2(m_bAudio2);
   if (!sound->Initialize())
   {
     delete sound;
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h
index f839843..08238c0 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAE.h
@@ -68,6 +68,7 @@ public:
 
   virtual void SetMute(const bool enabled);
   virtual bool IsMuted() { return m_muted; }
+  virtual bool IsDumb() { return m_bDumb; }
   virtual void SetSoundMode(const int mode) {}
 #if PA_CHECK_VERSION(1,0,0)
   virtual bool SupportsRaw() { return true; }
@@ -85,6 +86,7 @@ private:
   pa_threaded_mainloop *m_MainLoop;
   float m_Volume;
   bool m_muted;
+  bool m_bDumb;
 };
 
 #endif
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp
index 61db692..46ab5d1 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAESound.cpp
@@ -52,6 +52,7 @@ bool CPulseAESound::Initialize()
   /* we dont re-init the wav loader in PA as PA handles the samplerate */
   if (!m_wavLoader.IsValid())
     return false;
+  m_wavLoader.SetAudio2(m_bAudio2);
 
   m_sampleSpec.format   = PA_SAMPLE_FLOAT32NE;
   m_sampleSpec.rate     = m_wavLoader.GetSampleRate();
@@ -81,7 +82,7 @@ bool CPulseAESound::Initialize()
       return false;
   }
 
-  m_maxVolume     = CAEFactory::GetEngine()->GetVolume();
+  m_maxVolume     = CAEFactory::GetEngine(m_bAudio2)->GetVolume();
   m_volume        = 1.0f;
   pa_volume_t paVolume = pa_sw_volume_from_linear((double)(m_volume * m_maxVolume));
   pa_cvolume_set(&m_chVolume, m_sampleSpec.channels, paVolume);
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
index 9bea519..7c5e887 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
@@ -137,7 +137,7 @@ CPulseAEStream::CPulseAEStream(pa_context *context, pa_threaded_mainloop *mainLo
       default: break;
     }
 
-  m_MaxVolume     = CAEFactory::GetEngine()->GetVolume();
+  m_MaxVolume     = CAEFactory::GetEngine(m_bAudio2)->GetVolume();
   m_Volume        = 1.0f;
   pa_volume_t paVolume = pa_sw_volume_from_linear((double)(m_Volume * m_MaxVolume));
   pa_cvolume_set(&m_ChVolume, m_SampleSpec.channels, paVolume);
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
index 312f8fc..bf1cb9e 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.cpp
@@ -36,6 +36,7 @@
 #include "SoftAESound.h"
 #include "SoftAEStream.h"
 #include "AESinkFactory.h"
+#include "AEFactory.h"
 #include "Interfaces/AESink.h"
 #include "Utils/AEUtil.h"
 #include "Encoders/AEEncoderFFmpeg.h"
@@ -88,6 +89,7 @@ CSoftAE::CSoftAE():
   }
   CLog::Log(LOGNOTICE, "Found %lu Lists of Devices", m_sinkInfoList.size());
   PrintSinks();
+  m_bDumb = true;
 }
 
 CSoftAE::~CSoftAE()
@@ -189,6 +191,7 @@ void CSoftAE::InternalCloseSink()
     delete m_sink;
     m_sink = NULL;
   }
+  m_bDumb = true;
 }
 /* this must NEVER be called from outside the main thread or Initialization */
 void CSoftAE::InternalOpenSink()
@@ -320,12 +323,16 @@ void CSoftAE::InternalOpenSink()
     /* get the display name of the device */
     GetDeviceFriendlyName(device);
 
+	m_deviceCreate = device;
+
     /* if we already have a driver, prepend it to the device string */
     if (!driver.empty())
       device = driver + ":" + device;
 
     /* create the new sink */
     m_sink = GetSink(newFormat, m_transcode || m_rawPassthrough, device);
+	if(!IsDisabled() && m_sink && std::string(m_sink->GetName())!="NULL")
+      m_bDumb = false;
 
     /* perform basic sanity checks on the format returned by the sink */
     ASSERT(newFormat.m_channelLayout.Count() > 0);
@@ -335,7 +342,7 @@ void CSoftAE::InternalOpenSink()
     ASSERT(newFormat.m_frameSize            == (CAEUtil::DataFormatToBits(newFormat.m_dataFormat) >> 3) * newFormat.m_channelLayout.Count());
     ASSERT(newFormat.m_sampleRate            > 0);
 
-    CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink - %s Initialized:", m_sink->GetName());
+    CLog::Log(LOGDEBUG, "CSoftAE::InternalOpenSink%s - %s Initialized:", m_bAudio2 ? " 2nd" : "", m_sink->GetName());
     CLog::Log(LOGDEBUG, "  Output Device : %s", m_deviceFriendlyName.c_str());
     CLog::Log(LOGDEBUG, "  Sample Rate   : %d", newFormat.m_sampleRate);
     CLog::Log(LOGDEBUG, "  Sample Format : %s", CAEUtil::DataFormatToStr(newFormat.m_dataFormat));
@@ -495,6 +502,7 @@ bool CSoftAE::SetupEncoder(AEAudioFormat &format)
     return false;
 
   m_encoder = new CAEEncoderFFmpeg();
+  m_encoder->SetAudio2(m_bAudio2);
   if (m_encoder->Initialize(format))
     return true;
 
@@ -521,6 +529,9 @@ bool CSoftAE::Initialize()
 
 void CSoftAE::OnSettingsChange(const std::string& setting)
 {
+  if(m_bAudio2)
+    return OnSettingsChange2(setting);
+
   if (setting == "audiooutput.passthroughdevice" ||
       setting == "audiooutput.audiodevice"       ||
       setting == "audiooutput.mode"              ||
@@ -546,12 +557,42 @@ void CSoftAE::OnSettingsChange(const std::string& setting)
   }
 }
 
+void CSoftAE::OnSettingsChange2(const std::string& setting)
+{
+  if (setting == "audiooutput2.passthroughdevice" ||
+      setting == "audiooutput2.audiodevice"       ||
+      setting == "audiooutput2.mode"              ||
+      setting == "audiooutput2.ac3passthrough"    ||
+      setting == "audiooutput2.dtspassthrough"    ||
+      setting == "audiooutput2.passthroughaac"    ||
+      setting == "audiooutput2.truehdpassthrough" ||
+      setting == "audiooutput2.dtshdpassthrough"  ||
+      setting == "audiooutput2.channels"     ||
+      setting == "audiooutput2.useexclusivemode"  ||
+      setting == "audiooutput2.multichannellpcm"  ||
+      setting == "audiooutput2.stereoupmix")
+  {
+    OpenSink();
+  }
+
+  if (setting == "audiooutput2.normalizelevels" || setting == "audiooutput2.stereoupmix")
+  {
+    /* re-init stream reamppers */
+    CSingleLock streamLock(m_streamLock);
+    for (StreamList::iterator itt = m_streams.begin(); itt != m_streams.end(); ++itt)
+      (*itt)->InitializeRemap();
+  }
+}
+
 void CSoftAE::LoadSettings()
 {
   m_audiophile = g_advancedSettings.m_audioAudiophile;
   if (m_audiophile)
     CLog::Log(LOGINFO, "CSoftAE::LoadSettings - Audiophile switch enabled");
 
+  if(m_bAudio2)
+    return LoadSettings2();
+
   m_stereoUpmix = g_guiSettings.GetBool("audiooutput.stereoupmix");
   if (m_stereoUpmix)
     CLog::Log(LOGINFO, "CSoftAE::LoadSettings - Stereo upmix is enabled");
@@ -593,6 +634,71 @@ void CSoftAE::LoadSettings()
   );
 }
 
+void CSoftAE::LoadSettings2()
+{
+  m_stereoUpmix = g_guiSettings.GetBool("audiooutput2.stereoupmix");
+  if (m_stereoUpmix)
+    CLog::Log(LOGINFO, "CSoftAE::LoadSettings - Stereo upmix is enabled");
+
+  /* load the configuration */
+  m_stdChLayout = AE_CH_LAYOUT_2_0;
+  switch (g_guiSettings.GetInt("audiooutput2.channels"))
+  {
+    default:
+    case  0: m_stdChLayout = AE_CH_LAYOUT_2_0; break; /* dont alow 1_0 output */
+    case  1: m_stdChLayout = AE_CH_LAYOUT_2_0; break;
+    case  2: m_stdChLayout = AE_CH_LAYOUT_2_1; break;
+    case  3: m_stdChLayout = AE_CH_LAYOUT_3_0; break;
+    case  4: m_stdChLayout = AE_CH_LAYOUT_3_1; break;
+    case  5: m_stdChLayout = AE_CH_LAYOUT_4_0; break;
+    case  6: m_stdChLayout = AE_CH_LAYOUT_4_1; break;
+    case  7: m_stdChLayout = AE_CH_LAYOUT_5_0; break;
+    case  8: m_stdChLayout = AE_CH_LAYOUT_5_1; break;
+    case  9: m_stdChLayout = AE_CH_LAYOUT_7_0; break;
+    case 10: m_stdChLayout = AE_CH_LAYOUT_7_1; break;
+  }
+
+  // force optical/coax to 2.0 output channels
+  if (!m_rawPassthrough && g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_IEC958)
+    m_stdChLayout = AE_CH_LAYOUT_2_0;
+
+  /* get the output devices and ensure they exist */
+  m_device            = g_guiSettings.GetString("audiooutput2.audiodevice");
+  m_passthroughDevice = g_guiSettings.GetString("audiooutput2.passthroughdevice");
+  VerifySoundDevice(m_device           , false);
+  VerifySoundDevice(m_passthroughDevice, true );
+
+  m_transcode = (
+    g_guiSettings.GetBool("audiooutput2.ac3passthrough") /*||
+    g_guiSettings.GetBool("audiooutput2.dtspassthrough") */
+  ) && (
+      (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_IEC958) ||
+      (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_HDMI && !g_guiSettings.GetBool("audiooutput2.multichannellpcm"))
+  );
+
+  SetDisabled(g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE);
+  if(IsDisabled())
+  {
+    m_device = "NULL";
+    m_passthroughDevice = "NULL";
+    m_bDumb = true;
+  }
+  else
+  {
+    // avoid conflict with 1st audio
+    std::string device1 = CAEFactory::GetCreateDevice();
+    std::string device, driver;
+	device = m_device;
+    CAESinkFactory::ParseDevice(device, driver);
+	if(device == device1)
+      m_device = "NULL";
+	device = m_passthroughDevice;
+    CAESinkFactory::ParseDevice(device, driver);
+	if(device == device1)
+      m_passthroughDevice = "NULL";
+  }
+}
+
 void CSoftAE::VerifySoundDevice(std::string& device, bool passthrough)
 {
   /* check that the specified device exists */
@@ -779,6 +885,7 @@ IAEStream *CSoftAE::MakeStream(enum AEDataFormat dataFormat, unsigned int sample
 
   CSingleLock streamLock(m_streamLock);
   CSoftAEStream *stream = new CSoftAEStream(dataFormat, sampleRate, encodedSampleRate, channelLayout, options, m_streamLock);
+  stream->SetAudio2(m_bAudio2);
   m_newStreams.push_back(stream);
   streamLock.Leave();
   // this is really needed here
@@ -791,6 +898,7 @@ IAESound *CSoftAE::MakeSound(const std::string& file)
   CSingleLock soundLock(m_soundLock);
 
   CSoftAESound *sound = new CSoftAESound(file);
+  sound->SetAudio2(m_bAudio2);
   if (!sound->Initialize())
   {
     delete sound;
@@ -1369,7 +1477,7 @@ void CSoftAE::PrintSinks()
 unsigned int CSoftAE::RunRawStreamStage(unsigned int channelCount, void *out, bool &restart)
 {
   StreamList resumeStreams;
-  static StreamList::iterator itt;
+  StreamList::iterator itt;
   CSingleLock streamLock(m_streamLock);
   /* handle playing streams */
   for (itt = m_playingStreams.begin(); itt != m_playingStreams.end(); ++itt)
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
index 9672223..83546c3 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAE.h
@@ -65,6 +65,7 @@ public:
   virtual void  SetVolume(const float volume);
   virtual void  SetMute(const bool enabled) { m_muted = enabled; }
   virtual bool  IsMuted() { return m_muted; }
+  virtual bool  IsDumb() { return m_bDumb; }
   virtual void  SetSoundMode(const int mode);
 
   /* returns a new stream for data in the specified format */
@@ -100,6 +101,7 @@ public:
 
   virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
   virtual std::string GetDefaultDevice(bool passthrough);
+  virtual std::string GetCreateDevice() {return m_deviceCreate;}
   virtual bool SupportsRaw();
 
   /* internal stream methods */
@@ -112,6 +114,8 @@ private:
   CSoftAEStream *GetMasterStream();
 
   void LoadSettings();
+  void LoadSettings2();
+  void  OnSettingsChange2(const std::string& setting);
   void VerifySoundDevice(std::string &device, bool passthrough);
   void OpenSink();
 
@@ -132,6 +136,7 @@ private:
   std::string m_device;
   std::string m_passthroughDevice;
   std::string m_deviceFriendlyName;
+  std::string m_deviceCreate;
   bool m_audiophile;
   bool m_stereoUpmix;
 
@@ -155,6 +160,7 @@ private:
   /* the current configuration */
   float               m_volume;
   bool                m_muted;
+  bool                m_bDumb;
   CAEChannelInfo      m_chLayout;
   unsigned int        m_frameSize;
   double              m_frameSizeMul;
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
index c6d5065..09adb65 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAESound.cpp
@@ -32,7 +32,7 @@
 #include "SoftAESound.h"
 
 /* typecast AE to CSoftAE */
-#define AE (*((CSoftAE*)CAEFactory::GetEngine()))
+#define AE (*((CSoftAE*)CAEFactory::GetEngine(m_bAudio2)))
 
 typedef struct
 {
@@ -69,6 +69,7 @@ bool CSoftAESound::Initialize()
 {
   if (!m_wavLoader.IsValid())
     return false;
+  m_wavLoader.SetAudio2(m_bAudio2);
 
   return m_wavLoader.Initialize(
     AE.GetSampleRate   (),
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
index 12d00ea..dc94895 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
@@ -30,7 +30,7 @@
 #include "SoftAEStream.h"
 
 /* typecast AE to CSoftAE */
-#define AE (*((CSoftAE*)CAEFactory::GetEngine()))
+#define AE (*((CSoftAE*)CAEFactory::GetEngine(m_bAudio2)))
 
 using namespace std;
 
@@ -80,6 +80,8 @@ void CSoftAEStream::InitializeRemap()
   if (!AE_IS_RAW(m_initDataFormat))
   {
     /* re-init the remappers */
+	m_remap.SetAudio2(m_bAudio2);
+	m_vizRemap.SetAudio2(m_bAudio2);
     m_remap   .Initialize(m_initChannelLayout, AE.GetChannelLayout()           , false, false, AE.GetStdChLayout());
     m_vizRemap.Initialize(m_initChannelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true);
 
@@ -156,6 +158,8 @@ void CSoftAEStream::Initialize()
     m_newPacket->data.Alloc(m_format.m_frames * m_format.m_frameSize);
   else
   {
+    m_remap.SetAudio2(m_bAudio2);
+    m_vizRemap.SetAudio2(m_bAudio2);
     if (
       !m_remap   .Initialize(m_initChannelLayout, m_aeChannelLayout               , false, false, AE.GetStdChLayout()) ||
       !m_vizRemap.Initialize(m_initChannelLayout, CAEChannelInfo(AE_CH_LAYOUT_2_0), false, true))
diff --git a/xbmc/cores/AudioEngine/Interfaces/AE.h b/xbmc/cores/AudioEngine/Interfaces/AE.h
index 0baba37..5bf0a15 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AE.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AE.h
@@ -48,7 +48,7 @@ class IAE
 protected:
   friend class CAEFactory;
 
-  IAE() {}
+  IAE() { m_bAudio2 = false; m_bDisabled = false; }
   virtual ~IAE() {}
 
   /**
@@ -119,6 +119,7 @@ public:
    * @return The current mute state
    */
   virtual bool IsMuted() = 0;
+  virtual bool IsDumb() = 0;
 
   /**
    * Sets the sound mode
@@ -176,6 +177,7 @@ public:
    * @return the default audio device
    */
   virtual std::string GetDefaultDevice(bool passthrough) { return "default"; }
+  virtual std::string GetCreateDevice() { return ""; }
 
   /**
    * Returns true if the AudioEngine supports AE_FMT_RAW streams for use with formats such as IEC61937
@@ -183,5 +185,13 @@ public:
    * @returns true if the AudioEngine is capable of RAW output
    */
   virtual bool SupportsRaw() { return false; }
+
+  bool m_bAudio2;
+  bool m_bDisabled;
+
+public:
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+  void SetDisabled(bool bDisabled){ m_bDisabled = bDisabled; }
+  bool IsDisabled(){ return m_bDisabled; }
 };
 
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
index 9613d02..1e18a41 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
@@ -31,7 +31,7 @@ public:
   /**
    * Constructor
    */
-  IAEEncoder() {};
+  IAEEncoder() { m_bAudio2 = false; };
 
   /**
    * Destructor
@@ -96,5 +96,10 @@ public:
    * @return the delay in seconds including any un-fetched encoded data
    */
   virtual double GetDelay(unsigned int bufferSize) = 0;
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+
+  protected:
+	bool m_bAudio2;
 };
 
diff --git a/xbmc/cores/AudioEngine/Interfaces/AESound.h b/xbmc/cores/AudioEngine/Interfaces/AESound.h
index 100efdb..df424e9 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AESound.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AESound.h
@@ -26,7 +26,8 @@ class IAESound
 {
 protected:
   friend class IAE;
-  IAESound(const std::string &filename) {}
+  bool m_bAudio2;
+  IAESound(const std::string &filename) { m_bAudio2 = false; }
   virtual ~IAESound() {}
 
 public:
@@ -44,5 +45,8 @@ public:
 
   /* get the current playback volume of this sound */
   virtual float GetVolume() = 0;
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+  bool IsAudio2(){ return m_bAudio2; }
 };
 
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEStream.h b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
index 060fcb9..5f2d24e 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEStream.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
@@ -39,7 +39,8 @@ class IAEStream
 {
 protected:
   friend class IAE;
-  IAEStream() {}
+  bool m_bAudio2;
+  IAEStream() { m_bAudio2 = false; }
   virtual ~IAEStream() {}
 
 public:
@@ -225,5 +226,9 @@ public:
    * Slave a stream to resume when this stream has drained
    */
   virtual void RegisterSlave(IAEStream *stream) = 0;
+
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+
+  bool IsAudio2(){ return m_bAudio2; }
 };
 
diff --git a/xbmc/cores/AudioEngine/Utils/AERemap.cpp b/xbmc/cores/AudioEngine/Utils/AERemap.cpp
index c613c03..0b4fa34 100644
--- a/xbmc/cores/AudioEngine/Utils/AERemap.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AERemap.cpp
@@ -31,6 +31,7 @@ using namespace std;
 CAERemap::CAERemap() : m_inChannels(0), m_outChannels(0) 
 {
   memset(m_mixInfo, 0, sizeof(m_mixInfo));
+  m_bAudio2 = false;
 }
 
 CAERemap::~CAERemap()
@@ -197,7 +198,7 @@ bool CAERemap::Initialize(CAEChannelInfo input, CAEChannelInfo output, bool fina
 
   #undef RM
 
-  if (g_guiSettings.GetBool("audiooutput.stereoupmix"))
+  if (g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.stereoupmix" : "audiooutput2.stereoupmix"))
     BuildUpmixMatrix(input, output);
 
   /* normalize the values */
@@ -207,7 +208,7 @@ bool CAERemap::Initialize(CAEChannelInfo input, CAEChannelInfo output, bool fina
   else
   {
     //FIXME: guisetting is reversed, change the setting name after frodo
-    normalize = !g_guiSettings.GetBool("audiooutput.normalizelevels");
+    normalize = !g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.normalizelevels" : "audiooutput2.normalizelevels");
     CLog::Log(LOGDEBUG, "AERemap: Downmix normalization is %s", (normalize ? "enabled" : "disabled"));
   }
 
diff --git a/xbmc/cores/AudioEngine/Utils/AERemap.h b/xbmc/cores/AudioEngine/Utils/AERemap.h
index 49e984b..4ca59c0 100644
--- a/xbmc/cores/AudioEngine/Utils/AERemap.h
+++ b/xbmc/cores/AudioEngine/Utils/AERemap.h
@@ -26,6 +26,7 @@ public:
   CAERemap();
   ~CAERemap();
 
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
   bool Initialize(CAEChannelInfo input, CAEChannelInfo output, bool finalStage, bool forceNormalize = false, enum AEStdChLayout stdChLayout = AE_CH_LAYOUT_INVALID);
   void Remap(float * const in, float * const out, const unsigned int frames) const;
 
@@ -51,5 +52,7 @@ private:
 
   void ResolveMix(const AEChannel from, CAEChannelInfo to);
   void BuildUpmixMatrix(const CAEChannelInfo& input, const CAEChannelInfo& output);
+
+  bool           m_bAudio2;
 };
 
diff --git a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
index fb24d1a..b0f66c3 100644
--- a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.cpp
@@ -49,6 +49,7 @@ CAEWAVLoader::CAEWAVLoader() :
   m_samples           (NULL ),
   m_outputSamples     (NULL )
 {
+  m_bAudio2 = false;
 }
 
 CAEWAVLoader::~CAEWAVLoader()
@@ -280,6 +281,7 @@ bool CAEWAVLoader::Initialize(unsigned int resampleRate, CAEChannelInfo channelL
   if (m_channels != channelLayout)
   {
     CAERemap remap;
+    remap.SetAudio2(m_bAudio2);
     if (!remap.Initialize(m_channels, channelLayout, false, false, stdChLayout))
       return false;
 
diff --git a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h
index ac4c9b5..75381a1 100644
--- a/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h
+++ b/xbmc/cores/AudioEngine/Utils/AEWAVLoader.h
@@ -66,6 +66,8 @@ public:
   float*         GetSamples();
   bool           IsCompatible(const unsigned int sampleRate, const CAEChannelInfo &channelInfo);
 
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+
 private:
   std::string  m_filename;
   bool         m_valid;
@@ -75,5 +77,7 @@ private:
   unsigned int   m_frameCount  ,  m_outputFrameCount;
   unsigned int   m_sampleCount ,  m_outputSampleCount;
   float         *m_samples     , *m_outputSamples;
+
+  bool           m_bAudio2;
 };
 
diff --git a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
index bdb9c2a..3451167 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp
@@ -105,6 +105,7 @@ CDVDAudio::CDVDAudio(volatile bool &bStop)
   m_iBitrate = 0;
   m_SecondsPerByte = 0.0;
   m_bPaused = true;
+  m_bAudio2 = false;
 }
 
 CDVDAudio::~CDVDAudio()
@@ -116,7 +117,7 @@ CDVDAudio::~CDVDAudio()
   free(m_pBuffer);
 }
 
-bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler)
+bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler, bool bAudio2/* = false*/)
 {
   CLog::Log(LOGNOTICE,
     "Creating audio stream (codec id: %i, channels: %i, sample rate: %i, %s)",
@@ -136,7 +137,7 @@ bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool need
     audioframe.sample_rate,
     audioframe.encoded_sample_rate,
     audioframe.channel_layout,
-    options
+    options, bAudio2
   );
   if (!m_pAudioStream) return false;
 
@@ -157,6 +158,7 @@ bool CDVDAudio::Create(const DVDAudioFrame &audioframe, CodecID codec, bool need
   if (m_pAudioCallback)
     RegisterAudioCallback(m_pAudioCallback);
 
+  m_bAudio2 = bAudio2;
   return true;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDAudio.h b/xbmc/cores/dvdplayer/DVDAudio.h
index b2cbd46..60653aa 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.h
+++ b/xbmc/cores/dvdplayer/DVDAudio.h
@@ -80,7 +80,7 @@ public:
   float GetCurrentAttenuation();
   void Pause();
   void Resume();
-  bool Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler);
+  bool Create(const DVDAudioFrame &audioframe, CodecID codec, bool needresampler, bool bAudio2 = false);
   bool IsValidFormat(const DVDAudioFrame &audioframe);
   void Destroy();
   DWORD AddPackets(const DVDAudioFrame &audioframe);
@@ -116,4 +116,5 @@ protected:
   IAudioCallback* m_pAudioCallback; //the viz audio callback
   //counter that will go from 0 to m_iSpeed-1 and reset, data will only be output when speedstep is 0
   //int m_iSpeedStep;
+  bool m_bAudio2;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
index 3564a6c..f96b19a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodec.h
@@ -39,7 +39,7 @@ class CDVDAudioCodec
 {
 public:
 
-  CDVDAudioCodec() {}
+  CDVDAudioCodec() { m_bAudio2 = false; }
   virtual ~CDVDAudioCodec() {}
 
   /*
@@ -118,4 +118,10 @@ public:
    * should return amount of data decoded has buffered in preparation for next audio frame
    */
   virtual int GetBufferSize() { return 0; }
+  
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; };
+  
+  protected:
+  
+	bool m_bAudio2;
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index 880b710..7918a47 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -72,9 +72,9 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
   }
 
 #if defined(TARGET_DARWIN)
-  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  int audioMode = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode");
   if (audioMode == AUDIO_HDMI)
-    m_bLpcmMode = g_guiSettings.GetBool("audiooutput.multichannellpcm");
+    m_bLpcmMode = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.multichannellpcm" : "audiooutput2.multichannellpcm");
 #endif
 
   m_pCodecContext = m_dllAvCodec.avcodec_alloc_context3(pCodec);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
index b23ef60..9a7b9d4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.cpp
@@ -41,7 +41,7 @@ CDVDAudioCodecPassthrough::~CDVDAudioCodecPassthrough(void)
 bool CDVDAudioCodecPassthrough::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
   /* dont open if AE doesnt support RAW */
-  if (!CAEFactory::SupportsRaw())
+  if (!CAEFactory::SupportsRaw(m_bAudio2))
     return false;
 
   bool bSupportsAC3Out    = false;
@@ -49,17 +49,17 @@ bool CDVDAudioCodecPassthrough::Open(CDVDStreamInfo &hints, CDVDCodecOptions &op
   bool bSupportsTrueHDOut = false;
   bool bSupportsDTSHDOut  = false;
 
-  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  int audioMode = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode");
   if (AUDIO_IS_BITSTREAM(audioMode))
   {
-    bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
-    bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
+    bSupportsAC3Out = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.ac3passthrough" : "audiooutput2.ac3passthrough");
+    bSupportsDTSOut = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.dtspassthrough" : "audiooutput2.dtspassthrough");
   }
 
   if (audioMode == AUDIO_HDMI)
   {
-    bSupportsTrueHDOut = g_guiSettings.GetBool("audiooutput.truehdpassthrough");
-    bSupportsDTSHDOut  = g_guiSettings.GetBool("audiooutput.dtshdpassthrough" ) && bSupportsDTSOut;
+    bSupportsTrueHDOut = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.truehdpassthrough" : "audiooutput2.truehdpassthrough");
+    bSupportsDTSHDOut  = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.dtshdpassthrough" : "audiooutput2.dtshdpassthrough" ) && bSupportsDTSOut;
   }
 
   /* only get the dts core from the parser if we don't support dtsHD */
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
index c8523b7..4487757 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Audio/DVDAudioCodecPassthroughFFmpeg.cpp
@@ -287,14 +287,14 @@ bool CDVDAudioCodecPassthroughFFmpeg::SupportsFormat(CDVDStreamInfo &hints)
 
 bool CDVDAudioCodecPassthroughFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  int audioMode = g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode");
 
   // TODO - move this stuff somewhere else
   if (AUDIO_IS_BITSTREAM(audioMode))
   {
-    m_bSupportsAC3Out = g_guiSettings.GetBool("audiooutput.ac3passthrough");
-    m_bSupportsDTSOut = g_guiSettings.GetBool("audiooutput.dtspassthrough");
-    m_bSupportsAACOut = g_guiSettings.GetBool("audiooutput.passthroughaac");
+    m_bSupportsAC3Out = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.ac3passthrough" : "audiooutput2.ac3passthrough");
+    m_bSupportsDTSOut = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.dtspassthrough" : "audiooutput2.dtspassthrough");
+    m_bSupportsAACOut = g_guiSettings.GetBool(!m_bAudio2 ? "audiooutput.passthroughaac" : "audiooutput2.passthroughaac");
   }
   else
     return false;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 6fb74b7..9a74b6e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -76,11 +76,12 @@ CDVDVideoCodec* CDVDFactoryCodec::OpenCodec(CDVDVideoCodec* pCodec, CDVDStreamIn
   return NULL;
 }
 
-CDVDAudioCodec* CDVDFactoryCodec::OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hints, CDVDCodecOptions &options )
+CDVDAudioCodec* CDVDFactoryCodec::OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hints, CDVDCodecOptions &options, bool bAudio2 /* = false */ )
 {
   try
   {
     CLog::Log(LOGDEBUG, "FactoryCodec - Audio: %s - Opening", pCodec->GetName());
+    pCodec->SetAudio2(bAudio2);
     if( pCodec->Open( hints, options ) )
     {
       CLog::Log(LOGDEBUG, "FactoryCodec - Audio: %s - Opened", pCodec->GetName());
@@ -266,7 +267,7 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
   return NULL;
 }
 
-CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool passthrough /* = true */)
+CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool passthrough /* = true */, bool bAudio2 /* = false */)
 {
   CDVDAudioCodec* pCodec = NULL;
   CDVDCodecOptions options;
@@ -278,14 +279,14 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool p
     {
       case CODEC_ID_AC3:
       case CODEC_ID_DTS:
-        pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options );
+        pCodec = OpenCodec( new CDVDAudioCodecPassthroughFFmpeg(), hint, options, bAudio2 );
         if( pCodec ) return pCodec;
         break;
       default:
         break;      
     }
 #endif
-    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options );
+    pCodec = OpenCodec( new CDVDAudioCodecPassthrough(), hint, options, bAudio2 );
     if( pCodec ) return pCodec;
   }
 
@@ -294,7 +295,7 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool p
   case CODEC_ID_MP2:
   case CODEC_ID_MP3:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLibMad(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLibMad(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -316,7 +317,7 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool p
   case CODEC_ID_PCM_ALAW:
   case CODEC_ID_PCM_MULAW:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecPcm(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -325,7 +326,7 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool p
   //case CODEC_ID_LPCM_S20BE:
   case CODEC_ID_LPCM_S24BE:
     {
-      pCodec = OpenCodec( new CDVDAudioCodecLPcm(), hint, options );
+      pCodec = OpenCodec( new CDVDAudioCodecLPcm(), hint, options, bAudio2 );
       if( pCodec ) return pCodec;
       break;
     }
@@ -337,7 +338,7 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec( CDVDStreamInfo &hint, bool p
     }
   }
 
-  pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options );
+  pCodec = OpenCodec( new CDVDAudioCodecFFmpeg(), hint, options, bAudio2 );
   if( pCodec ) return pCodec;
 
   return NULL;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
index b021762..7acdc3d 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.h
@@ -36,10 +36,10 @@ class CDVDFactoryCodec
 {
 public:
   static CDVDVideoCodec* CreateVideoCodec(CDVDStreamInfo &hint, unsigned int surfaces = 0, const std::vector<ERenderFormat>& formats = std::vector<ERenderFormat>());
-  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint, bool passthrough = true );
+  static CDVDAudioCodec* CreateAudioCodec(CDVDStreamInfo &hint, bool passthrough = true, bool bAudio2 = false );
   static CDVDOverlayCodec* CreateOverlayCodec(CDVDStreamInfo &hint );
 
-  static CDVDAudioCodec* OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
+  static CDVDAudioCodec* OpenCodec(CDVDAudioCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options, bool bAudio2 = false );
   static CDVDVideoCodec* OpenCodec(CDVDVideoCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
   static CDVDOverlayCodec* OpenCodec(CDVDOverlayCodec* pCodec, CDVDStreamInfo &hint, CDVDCodecOptions &options );
 };
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
index b7b6b43..df89c10 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
@@ -94,3 +94,21 @@ DemuxPacket* CDVDDemuxUtils::AllocateDemuxPacket(int iDataSize)
   }
   return pPacket;
 }
+
+DemuxPacket* CDVDDemuxUtils::DuplicateDemuxPacket(DemuxPacket* pPacket)
+{
+  if (NULL ==pPacket || pPacket->iSize <= 0)
+    return NULL;
+  DemuxPacket* pPacketDup = AllocateDemuxPacket( pPacket->iSize );
+  if( pPacketDup )
+  {
+    memcpy(pPacketDup->pData, pPacket->pData, pPacket->iSize);
+    pPacketDup->iSize = pPacket->iSize;
+    pPacketDup->iStreamId = pPacket->iStreamId;
+    pPacketDup->iGroupId = pPacket->iGroupId;
+    pPacketDup->pts = pPacket->pts;
+    pPacketDup->dts = pPacket->dts;
+    pPacketDup->duration = pPacket->duration;
+  }
+  return pPacketDup;
+}
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h
index 6e8e96d..759430c 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.h
@@ -27,5 +27,6 @@ class CDVDDemuxUtils
 public:
   static void FreeDemuxPacket(DemuxPacket* pPacket);
   static DemuxPacket* AllocateDemuxPacket(int iDataSize = 0);
+  static DemuxPacket* DuplicateDemuxPacket(DemuxPacket* pPacket);
 };
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index 79ddd86..a4ea45f 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -84,16 +84,21 @@ double CPTSInputQueue::Get(int64_t bytes, bool consume)
 class CDVDMsgAudioCodecChange : public CDVDMsg
 {
 public:
-  CDVDMsgAudioCodecChange(const CDVDStreamInfo &hints, CDVDAudioCodec* codec)
+  CDVDMsgAudioCodecChange(const CDVDStreamInfo &hints, CDVDAudioCodec* codec, CDVDAudioCodec* codec2)
     : CDVDMsg(GENERAL_STREAMCHANGE)
     , m_codec(codec)
+    , m_codec2(codec2)
     , m_hints(hints)
   {}
  ~CDVDMsgAudioCodecChange()
   {
-    delete m_codec;
+    if (m_codec)
+      delete m_codec;
+    if (m_codec2)
+      delete m_codec2;
   }
   CDVDAudioCodec* m_codec;
+  CDVDAudioCodec* m_codec2;
   CDVDStreamInfo  m_hints;
 };
 
@@ -103,9 +108,14 @@ CDVDPlayerAudio::CDVDPlayerAudio(CDVDClock* pClock, CDVDMessageQueue& parent)
 , m_messageQueue("audio")
 , m_messageParent(parent)
 , m_dvdAudio((bool&)m_bStop)
+, m_dvdAudio2((bool&)m_bStop)
 {
   m_pClock = pClock;
   m_pAudioCodec = NULL;
+  m_pAudioCodec2 = NULL;
+  m_bAudio2 = false;
+  m_bAudio2Skip = false;
+  m_bAudio2Dumb = false;
   m_audioClock = 0;
   m_droptime = 0;
   m_speed = DVD_PLAYSPEED_NORMAL;
@@ -145,7 +155,10 @@ CDVDPlayerAudio::~CDVDPlayerAudio()
 
 bool CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints )
 {
+  m_bAudio2 = (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE) ? false : true;
+
   bool passthrough = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode"));
+  bool passthrough2 = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode"));
 
   CLog::Log(LOGNOTICE, "Finding audio codec for: %i", hints.codec);
   CDVDAudioCodec* codec = CDVDFactoryCodec::CreateAudioCodec(hints, passthrough);
@@ -154,12 +167,23 @@ bool CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints )
     CLog::Log(LOGERROR, "Unsupported audio codec");
     return false;
   }
+  CDVDAudioCodec* codec2 = NULL;
+  if (m_bAudio2)
+  {
+    codec2 = CDVDFactoryCodec::CreateAudioCodec(hints, passthrough2, m_bAudio2);
+    if( !codec2 )
+    {
+      CLog::Log(LOGERROR, "Unsupported 2nd audio codec");
+      m_dvdAudio2.Destroy();
+      m_bAudio2 = false;
+    }
+  }
 
   if(m_messageQueue.IsInited())
-    m_messageQueue.Put(new CDVDMsgAudioCodecChange(hints, codec), 0);
+    m_messageQueue.Put(new CDVDMsgAudioCodecChange(hints, codec, codec2), 0);
   else
   {
-    OpenStream(hints, codec);
+    OpenStream(hints, codec, codec2);
     m_messageQueue.Init();
     CLog::Log(LOGNOTICE, "Creating audio thread");
     Create();
@@ -167,10 +191,14 @@ bool CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints )
   return true;
 }
 
-void CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints, CDVDAudioCodec* codec )
+void CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints, CDVDAudioCodec* codec, CDVDAudioCodec* codec2 )
 {
-  SAFE_DELETE(m_pAudioCodec);
+  if (m_pAudioCodec)
+    SAFE_DELETE(m_pAudioCodec);
   m_pAudioCodec = codec;
+  if (m_pAudioCodec2)
+    SAFE_DELETE(m_pAudioCodec2);
+  m_pAudioCodec2 = codec2;
 
   /* store our stream hints */
   m_streaminfo = hints;
@@ -229,9 +257,13 @@ void CDVDPlayerAudio::CloseStream(bool bWaitForBuffers)
   {
     m_bStop = false;
     m_dvdAudio.Drain();
+    if (m_bAudio2)
+      m_dvdAudio2.Drain();
     m_bStop = true;
   }
   m_dvdAudio.Destroy();
+  if (m_bAudio2)
+    m_dvdAudio2.Destroy();
 
   // uninit queue
   m_messageQueue.End();
@@ -243,15 +275,25 @@ void CDVDPlayerAudio::CloseStream(bool bWaitForBuffers)
     delete m_pAudioCodec;
     m_pAudioCodec = NULL;
   }
+  if (m_pAudioCodec2)
+  {
+    m_pAudioCodec2->Dispose();
+    delete m_pAudioCodec2;
+    m_pAudioCodec2 = NULL;
+  }
+
+  m_bAudio2 = false;
 }
 
 // decode one audio frame and returns its uncompressed size
-int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
+int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2, bool bDropPacket)
 {
   int result = 0;
 
   // make sure the sent frame is clean
   memset(&audioframe, 0, sizeof(DVDAudioFrame));
+  memset(&audioframe2, 0, sizeof(DVDAudioFrame));
+  m_audio2frames.Clear();
 
   while (!m_bStop)
   {
@@ -259,7 +301,7 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
     /* NOTE: the audio packet can contain several frames */
     while( !m_bStop && m_decode.size > 0 )
     {
-      if( !m_pAudioCodec )
+      if( !m_pAudioCodec || (m_bAudio2 && !m_pAudioCodec2) )
         return DECODE_FLAG_ERROR;
 
       /* the packet dts refers to the first audioframe that starts in the packet */
@@ -268,6 +310,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
         m_audioClock = dts;
 
       int len = m_pAudioCodec->Decode(m_decode.data, m_decode.size);
+      if (m_bAudio2)
+        m_pAudioCodec2->Decode(m_decode.data, m_decode.size);
       m_audioStats.AddSampleBytes(m_decode.size);
       if (len < 0)
       {
@@ -275,6 +319,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
         CLog::Log(LOGERROR, "CDVDPlayerAudio::DecodeFrame - Decode Error. Skipping audio packet");
         m_decode.Release();
         m_pAudioCodec->Reset();
+        if (m_bAudio2)
+          m_pAudioCodec2->Reset();
         return DECODE_FLAG_ERROR;
       }
 
@@ -284,6 +330,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
         CLog::Log(LOGERROR, "CDVDPlayerAudio:DecodeFrame - Codec tried to consume more data than available. Potential memory corruption");
         m_decode.Release();
         m_pAudioCodec->Reset();
+        if (m_bAudio2)
+          m_pAudioCodec2->Reset();
         return DECODE_FLAG_ERROR;
       }
 
@@ -295,6 +343,24 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
       audioframe.size = m_pAudioCodec->GetData(&audioframe.data);
       audioframe.pts  = m_audioClock;
 
+      if (m_bAudio2)
+      {
+        audioframe2.size = m_pAudioCodec2->GetData(&audioframe2.data);
+        if (audioframe2.size > 0)
+        {
+          audioframe2.channel_layout 	   = m_pAudioCodec2->GetChannelMap();
+          audioframe2.channel_count		   = m_pAudioCodec2->GetChannels();
+          audioframe2.encoded_channel_count = m_pAudioCodec2->GetEncodedChannels();
+          audioframe2.data_format		   = m_pAudioCodec2->GetDataFormat();
+          audioframe2.bits_per_sample	   = CAEUtil::DataFormatToBits(audioframe2.data_format);
+          audioframe2.sample_rate		   = m_pAudioCodec2->GetSampleRate();
+          audioframe2.encoded_sample_rate   = m_pAudioCodec2->GetEncodedSampleRate();
+          audioframe2.passthrough		   = m_pAudioCodec2->NeedPassthrough();
+
+          m_audio2frames.Add(audioframe2);
+        }
+      }
+
       if (audioframe.size <= 0)
         continue;
 
@@ -307,6 +373,12 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
       audioframe.encoded_sample_rate   = m_pAudioCodec->GetEncodedSampleRate();
       audioframe.passthrough           = m_pAudioCodec->NeedPassthrough();
 
+      if (m_bAudio2)
+      {
+        m_audio2frames.Merge(audioframe2);
+        audioframe2.pts = m_audioClock;
+      }
+
       if (m_streaminfo.samplerate != audioframe.sample_rate)
       {
         // The sample rate has changed or we just got it for the first time
@@ -318,6 +390,7 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
           m_decode.data -= len;
           m_decode.size += len;
           switched = true;
+          m_audio2frames.Clear();
           continue;
         }
       }
@@ -332,13 +405,25 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
         // increase audioclock to after the packet
         m_audioClock += audioframe.duration;
       }
+      if (m_bAudio2 && audioframe2.size > 0)
+      {
+        n = (audioframe2.channel_count * audioframe2.bits_per_sample * audioframe2.sample_rate)>>3;
+        if (n > 0)
+        {
+          // safety check, if channels == 0, n will result in 0, and that will result in a nice devide exception
+          audioframe2.duration = ((double)audioframe2.size * DVD_TIME_BASE) / n;
+        }
+      }
 
       if(audioframe.duration > 0)
         m_duration = audioframe.duration;
 
       // if demux source want's us to not display this, continue
       if(m_decode.msg->GetPacketDrop())
+      {
+        m_audio2frames.Clear();
         continue;
+      }
 
       //If we are asked to drop this packet, return a size of zero. then it won't be played
       //we currently still decode the audio.. this is needed since we still need to know it's
@@ -392,6 +477,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
 
       m_ptsInput.Flush();
       m_dvdAudio.SetPlayingPts(m_audioClock);
+      if (m_bAudio2)
+        m_dvdAudio2.SetPlayingPts(m_audioClock);
       if (pMsgGeneralResync->m_clock)
       {
         CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_RESYNC(%f, 1)", m_audioClock);
@@ -404,12 +491,16 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
     {
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      if (m_pAudioCodec2)
+        m_pAudioCodec2->Reset();
       m_decode.Release();
       m_started = false;
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH))
     {
       m_dvdAudio.Flush();
+      if (m_bAudio2)
+        m_dvdAudio2.Flush();
       m_ptsInput.Flush();
       m_syncclock = true;
       m_stalled   = true;
@@ -417,6 +508,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
 
       if (m_pAudioCodec)
         m_pAudioCodec->Reset();
+      if (m_pAudioCodec2)
+        m_pAudioCodec2->Reset();
 
       m_decode.Release();
     }
@@ -429,6 +522,8 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
     {
       CLog::Log(LOGDEBUG, "CDVDPlayerAudio - CDVDMsg::GENERAL_EOF");
       m_dvdAudio.Finish();
+      if (m_bAudio2)
+        m_dvdAudio2.Finish();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_DELAY))
     {
@@ -452,13 +547,21 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
       if (m_speed == DVD_PLAYSPEED_NORMAL)
       {
         m_dvdAudio.Resume();
+        if (m_bAudio2)
+          m_dvdAudio2.Resume();
       }
       else
       {
         m_syncclock = true;
         if (m_speed != DVD_PLAYSPEED_PAUSE)
+        {
           m_dvdAudio.Flush();
+          if (m_bAudio2)
+            m_dvdAudio2.Flush();
+        }
         m_dvdAudio.Pause();
+        if (m_bAudio2)
+          m_dvdAudio2.Pause();
       }
     }
     else if (pMsg->IsType(CDVDMsg::AUDIO_SILENCE))
@@ -472,8 +575,9 @@ int CDVDPlayerAudio::DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket)
     else if (pMsg->IsType(CDVDMsg::GENERAL_STREAMCHANGE))
     {
       CDVDMsgAudioCodecChange* msg(static_cast<CDVDMsgAudioCodecChange*>(pMsg));
-      OpenStream(msg->m_hints, msg->m_codec);
+      OpenStream(msg->m_hints, msg->m_codec, msg->m_codec2);
       msg->m_codec = NULL;
+      msg->m_codec2 = NULL;
     }
 
     pMsg->Release();
@@ -500,12 +604,15 @@ void CDVDPlayerAudio::Process()
   bool packetadded(false);
 
   DVDAudioFrame audioframe;
+  DVDAudioFrame audioframe2;
   m_audioStats.Start();
+  m_audiodiff = 0.0;
+  m_bAudio2Skip = false;
 
   while (!m_bStop)
   {
     //Don't let anybody mess with our global variables
-    result = DecodeFrame(audioframe, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 ||
+    result = DecodeFrame(audioframe, audioframe2, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 ||
                          CAEFactory::IsSuspended()); // blocks if no audio is available, but leaves critical section before doing so
 
     if( result & DECODE_FLAG_ERROR )
@@ -523,6 +630,11 @@ void CDVDPlayerAudio::Process()
       {
         m_dvdAudio.Drain();
         m_dvdAudio.Flush();
+        if (m_bAudio2)
+        {
+          m_dvdAudio2.Drain();
+          m_dvdAudio2.Flush();
+        }
       }
 
       continue;
@@ -560,10 +672,30 @@ void CDVDPlayerAudio::Process()
       if(!m_dvdAudio.Create(audioframe, m_streaminfo.codec, m_setsynctype == SYNC_RESAMPLE))
         CLog::Log(LOGERROR, "%s - failed to create audio renderer", __FUNCTION__);
     }
+    if (m_bAudio2 && audioframe2.size > 0 && !m_dvdAudio2.IsValidFormat(audioframe2))
+    {
+      if(m_speed)
+        m_dvdAudio2.Drain();
+		
+        m_dvdAudio2.Destroy();
+		
+      if(m_speed)
+        m_dvdAudio2.Resume();
+      else
+        m_dvdAudio2.Pause();
+		
+      if(!m_dvdAudio2.Create(audioframe2, m_streaminfo.codec, m_setsynctype == SYNC_RESAMPLE, m_bAudio2))
+        CLog::Log(LOGERROR, "%s - failed to create 2nd audio renderer", __FUNCTION__);
+    }
+	if (m_bAudio2)
+		m_bAudio2Dumb = CAEFactory::IsDumb(true);
 
     // Zero out the frame data if we are supposed to silence the audio
     if (m_silence)
+    {
       memset(audioframe.data, 0, audioframe.size);
+      memset(audioframe2.data, 0, audioframe2.size);
+    }
 
     if( result & DECODE_FLAG_DROP )
     {
@@ -586,7 +718,9 @@ void CDVDPlayerAudio::Process()
       SetSyncType(audioframe.passthrough);
 
       // add any packets play
-      packetadded = OutputPacket(audioframe);
+      if (m_bAudio2)
+        HandleSyncAudio2(audioframe2);
+      packetadded = OutputPacket(audioframe, audioframe2);
 
       // we are not running until something is cached in output device
       if(m_stalled && m_dvdAudio.GetCacheTime() > 0.0)
@@ -739,11 +873,49 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
   }
 }
 
-bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
+void CDVDPlayerAudio::HandleSyncAudio2(DVDAudioFrame &audioframe2)
+{
+  if(m_bAudio2Dumb)
+  {
+    m_audiodiff = 0.0;
+	return;
+  }
+  if(audioframe2.size <= 0)
+    return;
+
+  double threshold = 50000.0;
+  threshold = threshold > audioframe2.duration ? threshold : audioframe2.duration;
+
+  double dtm1 = m_dvdAudio.GetDelay();
+  double dtm2 = m_dvdAudio2.GetDelay();
+  double ddiff = (dtm1 - dtm2);
+
+  m_audiodiff = ddiff / DVD_TIME_BASE;
+
+  if (ddiff > threshold)
+  {
+    memset(audioframe2.data, 0, audioframe2.size);
+    m_dvdAudio2.AddPackets(audioframe2);
+  }
+
+  if (ddiff < -threshold)
+  {
+    m_bAudio2Skip = true;
+  }
+  else if (m_bAudio2Skip && ddiff > 0.0)
+  {
+    m_bAudio2Skip = false;
+  }
+}
+
+bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2)
 {
+  bool bAddAudio2 = (m_bAudio2 && !m_bAudio2Dumb && !m_bAudio2Skip && audioframe2.size > 0);
   if (m_synctype == SYNC_DISCON)
   {
     m_dvdAudio.AddPackets(audioframe);
+    if (bAddAudio2)
+      m_dvdAudio2.AddPackets(audioframe2);
   }
   else if (m_synctype == SYNC_SKIPDUP)
   {
@@ -753,6 +925,8 @@ bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
       if (!m_prevskipped)
       {
         m_dvdAudio.AddPackets(audioframe);
+        if (bAddAudio2)
+          m_dvdAudio2.AddPackets(audioframe2);
         m_skipdupcount++;
       }
     }
@@ -760,11 +934,18 @@ bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
     {
       m_dvdAudio.AddPackets(audioframe);
       m_dvdAudio.AddPackets(audioframe);
+      if (bAddAudio2)
+      {
+        m_dvdAudio2.AddPackets(audioframe2);
+        m_dvdAudio2.AddPackets(audioframe2);
+      }
       m_skipdupcount--;
     }
     else if (m_skipdupcount == 0)
     {
       m_dvdAudio.AddPackets(audioframe);
+      if (bAddAudio2)
+        m_dvdAudio2.AddPackets(audioframe2);
     }
   }
   else if (m_synctype == SYNC_RESAMPLE)
@@ -784,6 +965,8 @@ bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
     m_resampleratio = 1.0 / g_VideoReferenceClock.GetSpeed() + proportional + m_integral;
     m_dvdAudio.SetResampleRatio(m_resampleratio);
     m_dvdAudio.AddPackets(audioframe);
+    if (bAddAudio2)
+      m_dvdAudio2.AddPackets(audioframe2);
   }
 
   return true;
@@ -829,20 +1012,48 @@ void CDVDPlayerAudio::WaitForBuffers()
 bool CDVDPlayerAudio::SwitchCodecIfNeeded()
 {
   // check if passthrough is disabled
-  if (!AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode")))
+  bool bBitsOut = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode"));
+  bool bBitsOut2 = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode"));
+  if (!bBitsOut && (!m_bAudio2 || !bBitsOut2))
     return false;
+  else
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio: Sample rate changed, checking for passthrough");
 
-  CLog::Log(LOGDEBUG, "CDVDPlayerAudio: Sample rate changed, checking for passthrough");
-  CDVDAudioCodec *codec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, true);
-  if (!codec || codec->NeedPassthrough() == m_pAudioCodec->NeedPassthrough()) {
-    // passthrough state has not changed
-    delete codec;
-    return false;
+  bool bSwitched = false;
+  if (bBitsOut)
+  {
+    CDVDAudioCodec *codec = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, true);
+    if (codec != NULL)
+    {
+      if (codec->NeedPassthrough() == m_pAudioCodec->NeedPassthrough()) {
+        // passthrough state has not changed
+        delete codec;
+      }
+      else {
+        delete m_pAudioCodec;
+        m_pAudioCodec = codec;
+        bSwitched = true;
+      }
+    }
   }
 
-  delete m_pAudioCodec;
-  m_pAudioCodec = codec;
-  return true;
+  if (m_bAudio2 && bBitsOut2)
+  {
+    CDVDAudioCodec *codec2 = CDVDFactoryCodec::CreateAudioCodec(m_streaminfo, true, true);
+    if (codec2 != NULL)
+    {
+	  if (codec2->NeedPassthrough() == m_pAudioCodec2->NeedPassthrough()) {
+        // passthrough state has not changed
+        delete codec2;
+      }
+      else {
+        delete m_pAudioCodec2;
+        m_pAudioCodec2 = codec2;
+      }
+    }
+  }
+
+  return bSwitched;
 }
 
 string CDVDPlayerAudio::GetPlayerInfo()
@@ -856,6 +1067,9 @@ string CDVDPlayerAudio::GetPlayerInfo()
   if (m_synctype == SYNC_RESAMPLE)
     s << ", rr:" << fixed << setprecision(5) << 1.0 / m_resampleratio;
 
+  if (m_bAudio2)
+    s << ", a1/a2:" << fixed << setprecision(3) << m_audiodiff;
+
   s << ", att:" << fixed << setprecision(1) << log(GetCurrentAttenuation()) * 20.0f << " dB";
 
   return s.str();
@@ -868,5 +1082,5 @@ int CDVDPlayerAudio::GetAudioBitrate()
 
 bool CDVDPlayerAudio::IsPassthrough() const
 {
-  return m_pAudioCodec && m_pAudioCodec->NeedPassthrough();
+  return m_pAudioCodec && m_pAudioCodec->NeedPassthrough() && (!m_bAudio2 || (m_pAudioCodec2 && m_pAudioCodec2->NeedPassthrough()));
 }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.h b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
index 0b1d287..9e740e2 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
@@ -82,7 +82,7 @@ public:
   virtual ~CDVDPlayerAudio();
 
   bool OpenStream(CDVDStreamInfo &hints);
-  void OpenStream(CDVDStreamInfo &hints, CDVDAudioCodec* codec);
+  void OpenStream(CDVDStreamInfo &hints, CDVDAudioCodec* codec, CDVDAudioCodec* codec2);
   void CloseStream(bool bWaitForBuffers);
 
   void RegisterAudioCallback(IAudioCallback* pCallback) { m_dvdAudio.RegisterAudioCallback(pCallback); }
@@ -103,8 +103,8 @@ public:
   //! codec changes, in which case we may want to switch passthrough on/off.
   bool SwitchCodecIfNeeded();
 
-  void SetVolume(float fVolume)                         { m_dvdAudio.SetVolume(fVolume); }
-  void SetDynamicRangeCompression(long drc)             { m_dvdAudio.SetDynamicRangeCompression(drc); }
+  void SetVolume(float fVolume)                         { m_dvdAudio.SetVolume(fVolume); if(m_bAudio2) m_dvdAudio2.SetVolume(fVolume); }
+  void SetDynamicRangeCompression(long drc)             { m_dvdAudio.SetDynamicRangeCompression(drc); if(m_bAudio2) m_dvdAudio2.SetDynamicRangeCompression(drc); }
   float GetCurrentAttenuation()                         { return m_dvdAudio.GetCurrentAttenuation(); }
 
   std::string GetPlayerInfo();
@@ -126,7 +126,7 @@ protected:
   virtual void OnExit();
   virtual void Process();
 
-  int DecodeFrame(DVDAudioFrame &audioframe, bool bDropPacket);
+  int DecodeFrame(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2, bool bDropPacket);
 
   CDVDMessageQueue m_messageQueue;
   CDVDMessageQueue& m_messageParent;
@@ -173,9 +173,69 @@ protected:
     }
   } m_decode;
 
+  struct Audio2Frames
+  {
+    Audio2Frames()
+    {
+      incr = 64*1024;
+      capa = incr;
+      data = (BYTE*)malloc(capa);
+      size = 0;
+    }
+	  
+    ~Audio2Frames()
+    {
+      if(data)
+        free(data);
+    }
+
+    void Add(DVDAudioFrame& af)
+    {
+      if(!af.data || !af.size)
+        return;
+      if(size + af.size > capa)
+      {
+        capa = ((size + af.size) / incr + 1) * incr;
+        data = (BYTE*)realloc(data, capa);
+      }
+      memcpy(data+size, af.data, af.size);
+      size += af.size;
+      af.data = data + size;
+      afs.push_back(af);
+    }
+
+    bool Merge(DVDAudioFrame& af)
+    {
+      if (!afs.size())
+        return false;
+      af = afs.front();
+      af.data = data;
+      af.size = size;
+      af.duration = 0;
+      for (std::list<DVDAudioFrame>::iterator it = afs.begin(); it != afs.end(); ++it)
+        af.duration += it->duration;
+      return true;
+    }
+
+    void Clear()
+    {
+      afs.clear();
+      size = 0;
+    }
+
+  protected:
+    BYTE*                     data;
+    unsigned int              size;
+    unsigned int              capa;
+    unsigned int              incr;
+    std::list<DVDAudioFrame>  afs;
+  } m_audio2frames;
+
   CDVDAudio m_dvdAudio; // audio output device
+  CDVDAudio m_dvdAudio2; // audio output device 2
   CDVDClock* m_pClock; // dvd master clock
   CDVDAudioCodec* m_pAudioCodec; // audio codec
+  CDVDAudioCodec* m_pAudioCodec2; // audio codec 2
   BitstreamStats m_audioStats;
 
   int     m_speed;
@@ -185,7 +245,7 @@ protected:
   double  m_duration; // last packets duration
   bool    m_silence;
 
-  bool OutputPacket(DVDAudioFrame &audioframe);
+  bool OutputPacket(DVDAudioFrame &audioframe, DVDAudioFrame &audioframe2);
 
   //SYNC_DISCON, SYNC_SKIPDUP, SYNC_RESAMPLE
   int    m_synctype;
@@ -199,6 +259,7 @@ protected:
 
   void   SetSyncType(bool passthrough);
   void   HandleSyncError(double duration);
+  void   HandleSyncAudio2(DVDAudioFrame &audioframe2);
   double m_errorbuff; //place to store average errors
   int    m_errorcount;//number of errors stored
   bool   m_syncclock;
@@ -208,5 +269,10 @@ protected:
   bool   m_prevskipped;
   double m_maxspeedadjust;
   double m_resampleratio; //resample ratio when using SYNC_RESAMPLE, used for the codec info
+
+  bool   m_bAudio2;
+  bool   m_bAudio2Skip;
+  bool   m_bAudio2Dumb;
+  double m_audiodiff;
 };
 
diff --git a/xbmc/cores/paplayer/AudioDecoder.cpp b/xbmc/cores/paplayer/AudioDecoder.cpp
index 10d5505..21e16a2 100644
--- a/xbmc/cores/paplayer/AudioDecoder.cpp
+++ b/xbmc/cores/paplayer/AudioDecoder.cpp
@@ -35,6 +35,9 @@ CAudioDecoder::CAudioDecoder()
 
   m_status = STATUS_NO_FILE;
   m_canPlay = false;
+
+  m_bAudio2 = false;
+  m_bCheckAudio2 = false;
 }
 
 CAudioDecoder::~CAudioDecoder()
@@ -76,6 +79,11 @@ bool CAudioDecoder::Create(const CFileItem &file, int64_t seekOffset)
 
   // create our codec
   m_codec=CodecFactory::CreateCodecDemux(file.GetPath(), file.GetMimeType(), filecache * 1024);
+  if (m_codec)
+  {
+    m_codec->SetAudio2(m_bAudio2);
+    m_codec->SetCheckAudio2(m_bCheckAudio2);
+  }
 
   if (!m_codec || !m_codec->Init(file.GetPath(), filecache * 1024))
   {
diff --git a/xbmc/cores/paplayer/AudioDecoder.h b/xbmc/cores/paplayer/AudioDecoder.h
index 187df8c..41d5af3 100644
--- a/xbmc/cores/paplayer/AudioDecoder.h
+++ b/xbmc/cores/paplayer/AudioDecoder.h
@@ -75,6 +75,9 @@ public:
   void *GetData(unsigned int samples);
   ICodec *GetCodec() const { return m_codec; }
   float GetReplayGain();
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+  void SetCheckAudio2(bool bCheckAudio2){ m_bCheckAudio2 = m_bAudio2 ? false : bCheckAudio2; }
+  bool IsReusableForAudio2(){ return m_codec ? m_codec->IsReusableForAudio2() : false; }
 
 private:
   // pcm buffer
@@ -96,4 +99,7 @@ private:
   ICodec*          m_codec;
 
   CCriticalSection m_critSection;
+
+  bool    m_bAudio2;
+  bool    m_bCheckAudio2;
 };
diff --git a/xbmc/cores/paplayer/DVDPlayerCodec.cpp b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
index c4234b6..970759a 100644
--- a/xbmc/cores/paplayer/DVDPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/DVDPlayerCodec.cpp
@@ -145,8 +145,21 @@ bool DVDPlayerCodec::Init(const CStdString &strFile, unsigned int filecache)
 
   CDVDStreamInfo hint(*pStream, true);
 
-  bool passthrough = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput.mode"));
-  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, passthrough);
+  bool passthrough = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt(!m_bAudio2 ? "audiooutput.mode" : "audiooutput2.mode"));
+  m_pAudioCodec = CDVDFactoryCodec::CreateAudioCodec(hint, passthrough, m_bAudio2);
+  if (m_bCheckAudio2)
+  {
+    bool passthrough2 = AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode"));
+    CDVDAudioCodec* pAudioCodec2 = CDVDFactoryCodec::CreateAudioCodec(hint, passthrough2, true);
+    if (!m_pAudioCodec)
+      m_pAudioCodec = pAudioCodec2;
+    else if (pAudioCodec2)
+    {
+      if (pAudioCodec2->NeedPassthrough() != m_pAudioCodec->NeedPassthrough())
+        m_bReusableForAudio2 = false;
+      delete pAudioCodec2;
+    }
+  }
   if (!m_pAudioCodec)
   {
     CLog::Log(LOGERROR, "%s: Could not create audio codec", __FUNCTION__);
diff --git a/xbmc/cores/paplayer/ICodec.h b/xbmc/cores/paplayer/ICodec.h
index 8a41279..3f1b5b3 100644
--- a/xbmc/cores/paplayer/ICodec.h
+++ b/xbmc/cores/paplayer/ICodec.h
@@ -43,6 +43,9 @@ public:
     m_Channels = 0;
     m_Bitrate = 0;
     m_CodecName = "";
+	m_bAudio2 = false;
+    m_bCheckAudio2 = false;
+    m_bReusableForAudio2 = true;
   };
   virtual ~ICodec() {};
 
@@ -107,8 +110,16 @@ public:
   MUSIC_INFO::CMusicInfoTag m_tag;
   XFILE::CFile m_file;
 
+  void SetAudio2(bool bAudio2){ m_bAudio2 = bAudio2; }
+  bool IsAudio2() { return m_bAudio2; }
+  void SetCheckAudio2(bool bCheckAudio2){ m_bCheckAudio2 = m_bAudio2 ? false : bCheckAudio2; }
+  bool IsReusableForAudio2(){ return m_bReusableForAudio2; }
+
 protected:
   int m_Channels; /* remove this soon, its being deprecated */
 
+  bool m_bAudio2;
+  bool m_bCheckAudio2;
+  bool m_bReusableForAudio2;
 };
 
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index fd4e1a7..868dba4 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -62,6 +62,9 @@ PAPlayer::PAPlayer(IPlayerCallback& callback) :
   m_FileItem           (new CFileItem())
 {
   memset(&m_playerGUIData, 0, sizeof(m_playerGUIData));
+  m_bAudio2 = false;
+  m_iTimeSynced = 0;
+  m_iAudio2DiscardSamples = 0;
 }
 
 PAPlayer::~PAPlayer()
@@ -98,6 +101,11 @@ void PAPlayer::SoftStart(bool wait/* = false */)
 
     si->m_stream->FadeVolume(0.0f, 1.0f, FAST_XFADE_TIME);
     si->m_stream->Resume();
+    if(m_bAudio2)
+    {
+	  si->m_stream2->FadeVolume(0.0f, 1.0f, FAST_XFADE_TIME);
+      si->m_stream2->Resume();
+    }
   }
   
   if (wait)
@@ -136,6 +144,8 @@ void PAPlayer::SoftStop(bool wait/* = false */, bool close/* = true */)
     StreamInfo* si = *itt;
     if (si->m_stream)
       si->m_stream->FadeVolume(1.0f, 0.0f, FAST_XFADE_TIME);
+    if(m_bAudio2 && si->m_stream2)
+      si->m_stream2->FadeVolume(1.0f, 0.0f, FAST_XFADE_TIME);
 
     if (close)
     {
@@ -178,6 +188,8 @@ void PAPlayer::SoftStop(bool wait/* = false */, bool close/* = true */)
       {
         StreamInfo* si = *itt;
         si->m_stream->Pause();
+        if(m_bAudio2)
+          si->m_stream2->Pause();
       }
     }
   }
@@ -198,8 +210,15 @@ void PAPlayer::CloseAllStreams(bool fade/* = true */)
         CAEFactory::FreeStream(si->m_stream);
         si->m_stream = NULL;
       }
+      if(m_bAudio2 && si->m_stream2)
+      {
+        CAEFactory::FreeStream(si->m_stream2);
+        si->m_stream2 = NULL;
+      }
 
       si->m_decoder.Destroy();
+      if(si->m_usedecoder2)
+        si->m_decoder2.Destroy();
       delete si;
     }
 
@@ -213,8 +232,15 @@ void PAPlayer::CloseAllStreams(bool fade/* = true */)
         CAEFactory::FreeStream(si->m_stream);
         si->m_stream = NULL;
       }
+      if(m_bAudio2 && si->m_stream2)
+      {
+        CAEFactory::FreeStream(si->m_stream2);
+        si->m_stream2 = NULL;
+      }
 
       si->m_decoder.Destroy();
+      if(si->m_usedecoder2)
+        si->m_decoder2.Destroy();
       delete si;
     }
     m_currentStream = NULL;
@@ -293,6 +319,9 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
 {
   StreamInfo *si = new StreamInfo();
 
+  m_bAudio2 = (g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_NONE) ? false : true;
+
+  si->m_decoder.SetCheckAudio2(m_bAudio2);
   if (!si->m_decoder.Create(file, (file.m_lStartOffset * 1000) / 75))
   {
     CLog::Log(LOGWARNING, "PAPlayer::QueueNextFileEx - Failed to create the decoder");
@@ -302,6 +331,18 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
     return false;
   }
 
+  si->m_usedecoder2 = false;
+  if (m_bAudio2)
+  {
+    si->m_decoder2.SetAudio2(true);
+    if (si->m_decoder.IsReusableForAudio2())
+      CLog::Log(LOGINFO, "PAPlayer::QueueNextFileEx - Reuse for 2nd decoder");
+    else if (si->m_decoder2.Create(file, (file.m_lStartOffset * 1000) / 75))
+      si->m_usedecoder2 = true;
+    else
+      CLog::Log(LOGWARNING, "PAPlayer::QueueNextFileEx - Failed to create 2nd decoder");
+  }
+
   /* decode until there is data-available */
   si->m_decoder.Start();
   while(si->m_decoder.GetDataSize() == 0)
@@ -314,6 +355,8 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
       CLog::Log(LOGINFO, "PAPlayer::QueueNextFileEx - Error reading samples");
 
       si->m_decoder.Destroy();
+      if(si->m_usedecoder2)
+	    si->m_decoder2.Destroy();
       delete si;
       m_callback.OnQueueNextItem();
       return false;
@@ -323,6 +366,28 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
     CThread::Sleep(1);
   }
 
+  if (si->m_usedecoder2)
+  {
+    si->m_decoder2.Start();
+	while(si->m_decoder2.GetDataSize() == 0)
+	{
+	  int status = si->m_decoder2.GetStatus();
+	  if (status == STATUS_ENDED   ||
+		  status == STATUS_NO_FILE ||
+		  si->m_decoder2.ReadSamples(PACKET_SIZE) == RET_ERROR)
+	  {
+		CLog::Log(LOGINFO, "PAPlayer::QueueNextFileEx 2nd - Error reading samples");
+
+        si->m_decoder2.Destroy();
+        si->m_usedecoder2 = false;
+        break;
+	  }
+	
+	  /* yield our time so that the main PAP thread doesnt stall */
+	  CThread::Sleep(1);
+	}
+  }
+
   UpdateCrossfadeTime(file);
 
   /* init the streaminfo struct */
@@ -331,12 +396,30 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
   si->m_endOffset          = file.m_lEndOffset   * 1000 / 75;
   si->m_bytesPerSample     = CAEUtil::DataFormatToBits(si->m_dataFormat) >> 3;
   si->m_bytesPerFrame      = si->m_bytesPerSample * si->m_channelInfo.Count();
+  if (si->m_usedecoder2)
+  {
+    si->m_decoder2.GetDataFormat(&si->m_channelInfo2, &si->m_sampleRate2, &si->m_encodedSampleRate2, &si->m_dataFormat2);
+    si->m_bytesPerSample2    = CAEUtil::DataFormatToBits(si->m_dataFormat2) >> 3;
+    si->m_bytesPerFrame2     = si->m_bytesPerSample2 * si->m_channelInfo2.Count();
+  }
+  else
+  {
+    si->m_channelInfo2       = si->m_channelInfo;
+    si->m_sampleRate2        = si->m_sampleRate;
+    si->m_encodedSampleRate2 = si->m_encodedSampleRate;
+    si->m_dataFormat2        = si->m_dataFormat;
+    si->m_bytesPerSample2    = si->m_bytesPerSample;
+    si->m_bytesPerFrame2     = si->m_bytesPerFrame;
+  }
   si->m_started            = false;
   si->m_finishing          = false;
   si->m_framesSent         = 0;
+  si->m_framesSent2        = 0;
   si->m_seekNextAtFrame    = 0;
   si->m_seekFrame          = -1;
+  si->m_seekFrame2         = -1;
   si->m_stream             = NULL;
+  si->m_stream2            = NULL;
   si->m_volume             = (fadeIn && m_upcomingCrossfadeMS) ? 0.0f : 1.0f;
   si->m_fadeOutTriggered   = false;
   si->m_isSlaved           = false;
@@ -359,6 +442,8 @@ bool PAPlayer::QueueNextFileEx(const CFileItem &file, bool fadeIn/* = true */)
     CLog::Log(LOGINFO, "PAPlayer::QueueNextFileEx - Error preparing stream");
     
     si->m_decoder.Destroy();
+    if(si->m_usedecoder2)
+      si->m_decoder2.Destroy();
     delete si;
     m_callback.OnQueueNextItem();
     return false;
@@ -413,12 +498,41 @@ inline bool PAPlayer::PrepareStream(StreamInfo *si)
   si->m_stream->SetVolume    (si->m_volume);
   si->m_stream->SetReplayGain(si->m_decoder.GetReplayGain());
 
+  if(m_bAudio2)
+  {
+    si->m_stream2 = CAEFactory::MakeStream(
+      si->m_dataFormat2,
+      si->m_sampleRate2,
+      si->m_encodedSampleRate2,
+      si->m_channelInfo2,
+      AESTREAM_PAUSED, true
+    );
+
+    if (!si->m_stream2)
+    {
+      CLog::Log(LOGDEBUG, "PAPlayer::PrepareStream 2nd - Failed to get IAEStream");
+      if (si->m_usedecoder2)
+      {
+        si->m_decoder2.Destroy();
+        si->m_usedecoder2 = false;
+      }
+      m_bAudio2 = false;
+    }
+    else
+    {
+      si->m_stream2->SetVolume    (si->m_volume);
+      si->m_stream2->SetReplayGain(si->m_usedecoder2 ? si->m_decoder2.GetReplayGain() : si->m_decoder.GetReplayGain());
+    }
+  }
+
   /* if its not the first stream and crossfade is not enabled */
   if (m_currentStream && m_currentStream != si && !m_upcomingCrossfadeMS)
   {
     /* slave the stream for gapless */
     si->m_isSlaved = true;
     m_currentStream->m_stream->RegisterSlave(si->m_stream);
+    if(m_bAudio2)
+      m_currentStream->m_stream2->RegisterSlave(si->m_stream2);
   }
 
   /* fill the stream's buffer */
@@ -440,6 +554,24 @@ inline bool PAPlayer::PrepareStream(StreamInfo *si)
     CThread::Sleep(1);
   }
 
+  while(si->m_usedecoder2 && si->m_stream2->IsBuffering())
+  {
+    int status = si->m_decoder2.GetStatus();
+    if (status == STATUS_ENDED   ||
+        status == STATUS_NO_FILE ||
+        si->m_decoder2.ReadSamples(PACKET_SIZE) == RET_ERROR)
+    {
+      CLog::Log(LOGINFO, "PAPlayer::PrepareStream 2nd - Stream Finished");
+      break;
+    }
+
+    if (!QueueData2(si))
+      break;
+
+    /* yield our time so that the main PAP thread doesnt stall */
+    CThread::Sleep(1);
+  }
+
   CLog::Log(LOGINFO, "PAPlayer::PrepareStream - Ready");
 
   return true;
@@ -489,6 +621,8 @@ void PAPlayer::Process()
       CThread::Sleep(MathUtils::round_int((delay - watermark) * 1000.0));
 
     GetTimeInternal(); //update for GUI
+
+    SyncStreams2();
   }
 }
 
@@ -507,10 +641,12 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
   for(StreamList::iterator itt = m_finishing.begin(); itt != m_finishing.end();)
   {
     StreamInfo* si = *itt;
-    if (si->m_stream->IsDrained())
+    if (si->m_stream->IsDrained() && (!m_bAudio2 || si->m_stream2->IsDrained()))
     {      
       itt = m_finishing.erase(itt);
       CAEFactory::FreeStream(si->m_stream);
+      if(m_bAudio2)
+        CAEFactory::FreeStream(si->m_stream2);
       delete si;
       CLog::Log(LOGDEBUG, "PAPlayer::ProcessStreams - Stream Freed");
     }
@@ -527,6 +663,7 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
     if (!m_currentStream && !si->m_started)
     {
       m_currentStream = si;
+      CLog::Log(LOGDEBUG, "PAPlayer::ProcessStreams - Stream switched");
       UpdateGUIData(si); //update for GUI
     }
     /* if the stream is finishing */
@@ -565,6 +702,15 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
       si->m_stream->UnRegisterAudioCallback();
       si->m_decoder.Destroy();      
       si->m_stream->Drain();
+      if(m_bAudio2)
+      {
+        if (si->m_usedecoder2)
+        {
+          si->m_decoder2.Destroy();
+          si->m_usedecoder2 = false;
+        }
+        si->m_stream2->Drain();
+      }
       m_finishing.push_back(si);
       return;
     }
@@ -593,6 +739,8 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
         if (m_upcomingCrossfadeMS)
         {
           si->m_stream->FadeVolume(1.0f, 0.0f, m_upcomingCrossfadeMS);
+          if(m_bAudio2)
+            si->m_stream2->FadeVolume(1.0f, 0.0f, m_upcomingCrossfadeMS);
           si->m_fadeOutTriggered = true;
         }
         m_currentStream = NULL;
@@ -616,6 +764,12 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
     if (!si->m_isSlaved)
       si->m_stream->Resume();
     si->m_stream->FadeVolume(0.0f, 1.0f, m_upcomingCrossfadeMS);
+    if(m_bAudio2)
+    {
+      if (!si->m_isSlaved)
+        si->m_stream2->Resume();
+      si->m_stream2->FadeVolume(0.0f, 1.0f, m_upcomingCrossfadeMS);
+    }
     m_callback.OnPlayBackStarted();
   }
 
@@ -633,13 +787,16 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
     {
       time = (int64_t)((float)si->m_seekFrame / (float)si->m_sampleRate * 1000.0f);
       si->m_framesSent = (int)(si->m_seekFrame - ((float)si->m_startOffset * (float)si->m_sampleRate) / 1000.0f);
+      si->m_framesSent2 = (int)(si->m_seekFrame2 - ((float)si->m_startOffset * (float)si->m_sampleRate2) / 1000.0f);
       si->m_seekFrame  = -1;
+      si->m_seekFrame2  = -1;
       m_playerGUIData.m_time = time; //update for GUI
     }
     /* if its FF/RW */
     else
     {
       si->m_framesSent      += si->m_sampleRate * (m_playbackSpeed  - 1);
+      si->m_framesSent2     += si->m_sampleRate2 * (m_playbackSpeed  - 1);
       si->m_seekNextAtFrame  = si->m_framesSent + si->m_sampleRate / 2;
       time = (int64_t)(((float)si->m_framesSent / (float)si->m_sampleRate * 1000.0f) + (float)si->m_startOffset);
     }
@@ -649,11 +806,14 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
     {
       time = si->m_startOffset;
       si->m_framesSent      = (int)(si->m_startOffset * si->m_sampleRate / 1000);
+      si->m_framesSent2     = (int)(si->m_startOffset * si->m_sampleRate2 / 1000);
       si->m_seekNextAtFrame = 0;
       ToFFRW(1);
     }
 
     si->m_decoder.Seek(time);
+    if(si->m_usedecoder2)
+      si->m_decoder2.Seek(time);
   }
 
   int status = si->m_decoder.GetStatus();
@@ -669,6 +829,12 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
   if (!QueueData(si))
     return false;
 
+  if (si->m_usedecoder2)
+  {
+    si->m_decoder2.ReadSamples(PACKET_SIZE);
+    QueueData2(si);
+  }
+
   /* update the delay time if we are running */
   if (si->m_started)
   {
@@ -677,6 +843,14 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
     else
       delay = std::min(delay , si->m_stream->GetDelay());
     buffer = std::min(buffer, si->m_stream->GetCacheTotal());
+    if (m_bAudio2)
+    {
+      if (si->m_stream2->IsBuffering())
+        delay = 0.0;
+      else
+        delay = std::min(delay , si->m_stream2->GetDelay());
+      buffer = std::min(buffer, si->m_stream2->GetCacheTotal());
+    }
   }
 
   return true;
@@ -684,7 +858,10 @@ inline bool PAPlayer::ProcessStream(StreamInfo *si, double &delay, double &buffe
 
 bool PAPlayer::QueueData(StreamInfo *si)
 {
+  bool bAudio2 = m_bAudio2 && !si->m_usedecoder2 && si->m_stream2;
   unsigned int space   = si->m_stream->GetSpace();
+  if (bAudio2)
+    space = std::min(space, si->m_stream2->GetSpace());
   unsigned int samples = std::min(si->m_decoder.GetDataSize(), space / si->m_bytesPerSample);
   if (!samples)
     return true;
@@ -699,12 +876,112 @@ bool PAPlayer::QueueData(StreamInfo *si)
   unsigned int added = si->m_stream->AddData(data, samples * si->m_bytesPerSample);
   si->m_framesSent += added / si->m_bytesPerFrame;
 
+  if (bAudio2)
+  {
+    if(samples > m_iAudio2DiscardSamples)
+      samples -= m_iAudio2DiscardSamples;
+    else
+      samples = samples - (samples * si->m_bytesPerSample / si->m_bytesPerFrame * si->m_bytesPerFrame / si->m_bytesPerSample);
+    if(samples)
+      si->m_stream2->AddData(data, samples * si->m_bytesPerSample);
+    si->m_framesSent2 = si->m_framesSent;
+    m_iAudio2DiscardSamples = 0;
+  }
+
   const ICodec* codec = si->m_decoder.GetCodec();
   m_playerGUIData.m_cacheLevel = codec ? codec->GetCacheLevel() : 0; //update for GUI
 
   return true;
 }
 
+bool PAPlayer::QueueData2(StreamInfo *si)
+{
+  if (!si->m_usedecoder2)
+    return false;
+
+  unsigned int space   = si->m_stream2->GetSpace();
+  unsigned int samples = std::min(si->m_decoder2.GetDataSize(), space / si->m_bytesPerSample2);
+  if (!samples)
+    return true;
+
+  void* data = si->m_decoder2.GetData(samples);
+  if (!data)
+  {
+    CLog::Log(LOGERROR, "PAPlayer::QueueData 2nd - Failed to get data from the decoder");
+    return false;
+  }
+
+  unsigned int added = si->m_stream2->AddData(data, samples * si->m_bytesPerSample2);
+  si->m_framesSent2 += added / si->m_bytesPerFrame2;
+
+  return true;
+}
+
+inline void PAPlayer::SyncStreams2()
+{
+  if(!m_bAudio2)
+    return;
+
+  if(CAEFactory::IsDumb() || CAEFactory::IsDumb(true))
+    return;
+
+  if(!m_currentStream || !m_currentStream->m_stream || !m_currentStream->m_stream2)
+    return;
+
+  if(m_currentStream->m_usedecoder2)
+    return;
+
+  if(m_playbackSpeed != 1)
+    return;
+
+  int iTimeSynced = (int)((double)clock()/CLOCKS_PER_SEC*1000);
+  if(iTimeSynced - m_iTimeSynced < 50)
+    return;
+  m_iTimeSynced = iTimeSynced;
+
+  double time1 = ((double)m_currentStream->m_framesSent / (double)m_currentStream->m_sampleRate);
+  double time2 = ((double)m_currentStream->m_framesSent2 / (double)m_currentStream->m_sampleRate2);
+  time1 -= m_currentStream->m_stream->GetDelay();
+  time2 -= m_currentStream->m_stream2->GetDelay();
+  double timediff = time2 - time1;
+
+  m_iAudio2DiscardSamples = 0;
+  if (timediff > 0.05)
+  {
+    unsigned int padsize = (unsigned int)(timediff * (double)m_currentStream->m_sampleRate2) * m_currentStream->m_bytesPerFrame2;
+    if(padsize > m_currentStream->m_stream2->GetSpace())
+      padsize = (m_currentStream->m_stream2->GetSpace() / m_currentStream->m_bytesPerFrame2) * m_currentStream->m_bytesPerFrame2;
+    if(padsize)
+    {
+      void* padbuf = malloc(padsize);
+      if(padbuf)
+      {
+        memset(padbuf, 0, padsize);
+        m_currentStream->m_stream2->AddData(padbuf, padsize);
+        free(padbuf);
+      }
+    }
+  }
+  else if(timediff < -0.05)
+  {
+    unsigned int discardsize = (unsigned int)(-timediff * (double)m_currentStream->m_sampleRate2) * m_currentStream->m_bytesPerFrame2;
+	m_iAudio2DiscardSamples = discardsize / m_currentStream->m_bytesPerSample2;
+    if (m_currentStream->m_usedecoder2)
+    {
+      if(m_iAudio2DiscardSamples > m_currentStream->m_decoder2.GetDataSize())
+        m_currentStream->m_decoder2.ReadSamples(m_iAudio2DiscardSamples - m_currentStream->m_decoder2.GetDataSize());
+      m_iAudio2DiscardSamples = std::min(m_currentStream->m_decoder2.GetDataSize(), m_iAudio2DiscardSamples);
+	  m_iAudio2DiscardSamples = m_iAudio2DiscardSamples * m_currentStream->m_bytesPerSample2 / m_currentStream->m_bytesPerFrame2 * m_currentStream->m_bytesPerFrame2 / m_currentStream->m_bytesPerSample2;
+      if (m_iAudio2DiscardSamples)
+      {
+        m_currentStream->m_decoder2.GetData(m_iAudio2DiscardSamples);
+        m_currentStream->m_framesSent2 += (m_iAudio2DiscardSamples * m_currentStream->m_bytesPerSample2 / m_currentStream->m_bytesPerFrame2);
+      }
+      m_iAudio2DiscardSamples = 0;
+    }
+  }
+}
+
 void PAPlayer::OnExit()
 {
 
@@ -890,6 +1167,7 @@ void PAPlayer::SeekTime(int64_t iTime /*=0*/)
     ToFFRW(1);
 
   m_currentStream->m_seekFrame = (int)((float)m_currentStream->m_sampleRate * ((float)iTime + (float)m_currentStream->m_startOffset) / 1000.0f);
+  m_currentStream->m_seekFrame2 = (int)((float)m_currentStream->m_sampleRate2 * ((float)iTime + (float)m_currentStream->m_startOffset) / 1000.0f);
   m_callback.OnPlayBackSeek((int)iTime, seekOffset);
 }
 
diff --git a/xbmc/cores/paplayer/PAPlayer.h b/xbmc/cores/paplayer/PAPlayer.h
index 2463c32..37b3889 100644
--- a/xbmc/cores/paplayer/PAPlayer.h
+++ b/xbmc/cores/paplayer/PAPlayer.h
@@ -103,10 +103,19 @@ private:
     enum AEDataFormat m_dataFormat;          /* data format of the samples */
     unsigned int      m_bytesPerSample;      /* number of bytes per audio sample */
     unsigned int      m_bytesPerFrame;       /* number of bytes per audio frame */
+    bool              m_usedecoder2;
+    CAudioDecoder     m_decoder2;            /* the stream decoder */
+    CAEChannelInfo    m_channelInfo2;        /* channel layout information */
+    unsigned int      m_sampleRate2;         /* sample rate of the stream */
+    unsigned int      m_encodedSampleRate2;  /* the encoded sample rate of raw streams */
+    enum AEDataFormat m_dataFormat2;         /* data format of the samples */
+    unsigned int      m_bytesPerSample2;     /* number of bytes per audio sample */
+    unsigned int      m_bytesPerFrame2;      /* number of bytes per audio frame */
 
     bool              m_started;             /* if playback of this stream has been started */
     bool              m_finishing;           /* if this stream is finishing */
     int               m_framesSent;          /* number of frames sent to the stream */
+    int               m_framesSent2;         /* number of frames sent to the stream */
     int               m_prepareNextAtFrame;  /* when to prepare the next stream */
     bool              m_prepareTriggered;    /* if the next stream has been prepared */
     int               m_playNextAtFrame;     /* when to start playing the next stream */
@@ -114,8 +123,10 @@ private:
     bool              m_fadeOutTriggered;    /* if the stream has been told to fade out */
     int               m_seekNextAtFrame;     /* the FF/RR sample to seek at */
     int               m_seekFrame;           /* the exact position to seek too, -1 for none */
+    int               m_seekFrame2;          /* the exact position to seek too, -1 for none */
 
     IAEStream*        m_stream;              /* the playback stream */
+    IAEStream*        m_stream2;             /* the playback stream */
     float             m_volume;              /* the initial volume level to set the stream to on creation */
 
     bool              m_isSlaved;            /* true if the stream has been slaved to another */
@@ -139,6 +150,9 @@ private:
   CSharedSection      m_streamsLock;         /* lock for the stream list */
   StreamList          m_streams;             /* playing streams */  
   StreamList          m_finishing;           /* finishing streams */
+  bool                m_bAudio2;
+  int                 m_iTimeSynced;
+  unsigned int        m_iAudio2DiscardSamples;
 
   bool QueueNextFileEx(const CFileItem &file, bool fadeIn = true);
   void SoftStart(bool wait = false);
@@ -148,6 +162,8 @@ private:
   bool PrepareStream(StreamInfo *si);
   bool ProcessStream(StreamInfo *si, double &delay, double &buffer);
   bool QueueData(StreamInfo *si);
+  bool QueueData2(StreamInfo *si);
+  void SyncStreams2();
   int64_t GetTotalTime64();
   void UpdateCrossfadeTime(const CFileItem& file);
   void UpdateStreamInfoPlayNextAtFrame(StreamInfo *si, unsigned int crossFadingTime);
diff --git a/xbmc/guilib/GUIAudioManager.cpp b/xbmc/guilib/GUIAudioManager.cpp
index f057036..5599d47 100644
--- a/xbmc/guilib/GUIAudioManager.cpp
+++ b/xbmc/guilib/GUIAudioManager.cpp
@@ -36,6 +36,7 @@ CGUIAudioManager g_audioManager;
 CGUIAudioManager::CGUIAudioManager()
 {
   m_bEnabled = false;
+  m_bAudio2 = false;
 }
 
 CGUIAudioManager::~CGUIAudioManager()
@@ -59,12 +60,16 @@ void CGUIAudioManager::Stop()
   {
     if (it->second.initSound  ) it->second.initSound  ->Stop();
     if (it->second.deInitSound) it->second.deInitSound->Stop();
+    if (it->second.initSound2  ) it->second.initSound2  ->Stop();
+    if (it->second.deInitSound2) it->second.deInitSound2->Stop();
   }
 
   for (pythonSoundsMap::iterator it = m_pythonSounds.begin(); it != m_pythonSounds.end(); ++it)
   {
-    IAESound* sound = it->second;
+    IAESound* sound = it->second.sound;
     sound->Stop();
+    sound = it->second.sound2;
+    if (sound) sound->Stop();
   }
 }
 
@@ -81,8 +86,10 @@ void CGUIAudioManager::PlayActionSound(const CAction& action)
   if (it == m_actionSoundMap.end())
     return;
 
-  if (it->second)
-    it->second->Play();
+  if (it->second.sound)
+    it->second.sound->Play();
+  if (m_bAudio2 && it->second.sound2)
+    it->second.sound2->Play();
 }
 
 // \brief Play a sound associated with a window and its event
@@ -101,13 +108,16 @@ void CGUIAudioManager::PlayWindowSound(int id, WINDOW_SOUND event)
 
   CWindowSounds sounds=it->second;
   IAESound *sound = NULL;
+  IAESound *sound2 = NULL;
   switch (event)
   {
   case SOUND_INIT:
     sound = sounds.initSound;
+    sound2 = sounds.initSound2;
     break;
   case SOUND_DEINIT:
     sound = sounds.deInitSound;
+    sound2 = sounds.deInitSound2;
     break;
   }
 
@@ -115,6 +125,9 @@ void CGUIAudioManager::PlayWindowSound(int id, WINDOW_SOUND event)
     return;
 
   sound->Play();
+
+  if (m_bAudio2 && sound2)
+    sound2->Play();
 }
 
 // \brief Play a sound given by filename
@@ -130,17 +143,21 @@ void CGUIAudioManager::PlayPythonSound(const CStdString& strFileName)
   pythonSoundsMap::iterator itsb=m_pythonSounds.find(strFileName);
   if (itsb != m_pythonSounds.end())
   {
-    IAESound* sound = itsb->second;
+    IAESound* sound = itsb->second.sound;
     sound->Play();
+    sound = itsb->second.sound2;
+    if (m_bAudio2 && sound) sound->Play();
     return;
   }
 
-  IAESound *sound = LoadSound(strFileName);
-  if (!sound)
+  CAPSounds aps = LoadSound(strFileName);
+  if (!aps.sound)
     return;
 
-  m_pythonSounds.insert(pair<const CStdString, IAESound*>(strFileName, sound));
-  sound->Play();
+  m_pythonSounds.insert(pair<const CStdString, CAPSounds>(strFileName, aps));
+  aps.sound->Play();
+  if (m_bAudio2 && aps.sound2)
+    aps.sound2->Play();
 }
 
 void CGUIAudioManager::UnLoad()
@@ -161,7 +178,7 @@ void CGUIAudioManager::UnLoad()
     pythonSoundsMap::iterator it = m_pythonSounds.begin();
     while (it != m_pythonSounds.end())
     {
-      IAESound* sound = it->second;
+      IAESound* sound = it->second.sound;
       FreeSound(sound);
       m_pythonSounds.erase(it++);
     }
@@ -172,7 +189,7 @@ void CGUIAudioManager::UnLoad()
     actionSoundMap::iterator it = m_actionSoundMap.begin();
     while (it != m_actionSoundMap.end())
     {
-      IAESound* sound = it->second;
+      IAESound* sound = it->second.sound;
       FreeSound(sound);
       m_actionSoundMap.erase(it++);
     }
@@ -188,6 +205,7 @@ bool CGUIAudioManager::Load()
   CSingleLock lock(m_cs);
 
   UnLoad();
+  CheckAudio2();
 
   if (g_guiSettings.GetString("lookandfeel.soundskin")=="OFF")
     return true;
@@ -246,9 +264,9 @@ bool CGUIAudioManager::Load()
       if (id > 0 && !strFile.IsEmpty())
       {
         CStdString filename = URIUtils::AddFileToFolder(m_strMediaDir, strFile);
-        IAESound *sound = LoadSound(filename);
-        if (sound)
-          m_actionSoundMap.insert(pair<int, IAESound *>(id, sound));
+        CAPSounds aps = LoadSound(filename);
+        if (aps.sound)
+          m_actionSoundMap.insert(pair<int, CAPSounds>(id, aps));
       }
 
       pAction = pAction->NextSibling();
@@ -273,8 +291,13 @@ bool CGUIAudioManager::Load()
       }
 
       CWindowSounds sounds;
-      sounds.initSound   = LoadWindowSound(pWindow, "activate"  );
-      sounds.deInitSound = LoadWindowSound(pWindow, "deactivate");
+	  CAPSounds aps;
+	  aps = LoadWindowSound(pWindow, "activate"  );
+	  sounds.initSound   = aps.sound;
+	  sounds.initSound2   = aps.sound2;
+	  aps = LoadWindowSound(pWindow, "deactivate"  );
+      sounds.deInitSound = aps.sound;
+      sounds.deInitSound2 = aps.sound2;
 
       if (id > 0)
         m_windowSoundMap.insert(pair<int, CWindowSounds>(id, sounds));
@@ -286,26 +309,34 @@ bool CGUIAudioManager::Load()
   return true;
 }
 
-IAESound* CGUIAudioManager::LoadSound(const CStdString &filename)
+CGUIAudioManager::CAPSounds CGUIAudioManager::LoadSound(const CStdString &filename)
 {
   CSingleLock lock(m_cs);
+  CAPSounds aps;
+  aps.sound = aps.sound2 = NULL;
   soundCache::iterator it = m_soundCache.find(filename);
   if (it != m_soundCache.end())
   {
     ++it->second.usage;
-    return it->second.sound;
+	aps.sound = it->second.sound;
+	aps.sound2 = it->second.sound2;
+    return aps;
   }
 
   IAESound *sound = CAEFactory::MakeSound(filename);
   if (!sound)
-    return NULL;
+    return aps;
+  IAESound *sound2 = CAEFactory::MakeSound(filename,true);
 
   CSoundInfo info;
   info.usage = 1;
   info.sound = sound;
+  info.sound2 = sound2;
   m_soundCache[filename] = info;
 
-  return info.sound;
+  aps.sound = info.sound;
+  aps.sound2 = info.sound2;
+  return aps;
 }
 
 void CGUIAudioManager::FreeSound(IAESound *sound)
@@ -315,6 +346,7 @@ void CGUIAudioManager::FreeSound(IAESound *sound)
     if (it->second.sound == sound) {
       if (--it->second.usage == 0) {     
         CAEFactory::FreeSound(sound);
+        if(it->second.sound2) CAEFactory::FreeSound(it->second.sound2);
         m_soundCache.erase(it);
       }
       return;
@@ -323,16 +355,19 @@ void CGUIAudioManager::FreeSound(IAESound *sound)
 }
 
 // \brief Load a window node of the config file (sounds.xml)
-IAESound* CGUIAudioManager::LoadWindowSound(TiXmlNode* pWindowNode, const CStdString& strIdentifier)
+CGUIAudioManager::CAPSounds CGUIAudioManager::LoadWindowSound(TiXmlNode* pWindowNode, const CStdString& strIdentifier)
 {
+  CAPSounds aps;
+  aps.sound = aps.sound2 = NULL;
+
   if (!pWindowNode)
-    return NULL;
+    return aps;
 
   TiXmlNode* pFileNode = pWindowNode->FirstChild(strIdentifier);
   if (pFileNode && pFileNode->FirstChild())
     return LoadSound(URIUtils::AddFileToFolder(m_strMediaDir, pFileNode->FirstChild()->Value()));
 
-  return NULL;
+  return aps;
 }
 
 // \brief Enable/Disable nav sounds
@@ -355,8 +390,10 @@ void CGUIAudioManager::SetVolume(float level)
     actionSoundMap::iterator it = m_actionSoundMap.begin();
     while (it!=m_actionSoundMap.end())
     {
-      if (it->second)
-        it->second->SetVolume(level);
+      if (it->second.sound)
+        it->second.sound->SetVolume(level);
+      if (it->second.sound2)
+        it->second.sound2->SetVolume(level);
       ++it;
     }
   }
@@ -365,16 +402,25 @@ void CGUIAudioManager::SetVolume(float level)
   {
     if (it->second.initSound  ) it->second.initSound  ->SetVolume(level);
     if (it->second.deInitSound) it->second.deInitSound->SetVolume(level);
+    if (it->second.initSound2  ) it->second.initSound2  ->SetVolume(level);
+    if (it->second.deInitSound2) it->second.deInitSound2->SetVolume(level);
   }
 
   {
     pythonSoundsMap::iterator it = m_pythonSounds.begin();
     while (it != m_pythonSounds.end())
     {
-      if (it->second)
-        it->second->SetVolume(level);
+      if (it->second.sound)
+        it->second.sound->SetVolume(level);
+      if (it->second.sound2)
+        it->second.sound2->SetVolume(level);
 
       ++it;
     }
   }
 }
+
+void CGUIAudioManager::CheckAudio2()
+{
+  m_bAudio2 = (g_guiSettings.GetInt("audiooutput2.mode") != AUDIO_NONE);
+}
diff --git a/xbmc/guilib/GUIAudioManager.h b/xbmc/guilib/GUIAudioManager.h
index c80c66f..f456cbd 100644
--- a/xbmc/guilib/GUIAudioManager.h
+++ b/xbmc/guilib/GUIAudioManager.h
@@ -41,6 +41,15 @@ class CGUIAudioManager
   public:
     IAESound *initSound;
     IAESound *deInitSound;
+    IAESound *initSound2;
+    IAESound *deInitSound2;
+  };
+
+  class CAPSounds
+  {
+  public:
+    IAESound *sound;      
+    IAESound *sound2;
   };
 
   class CSoundInfo
@@ -48,6 +57,7 @@ class CGUIAudioManager
   public:
     int usage;
     IAESound *sound;      
+    IAESound *sound2;
   };
 
 public:
@@ -65,14 +75,15 @@ public:
   void PlayWindowSound(int id, WINDOW_SOUND event);
   void PlayPythonSound(const CStdString& strFileName);
 
+  void CheckAudio2();
   void Enable(bool bEnable);
   void SetVolume(float level);
   void Stop();
 private:
   typedef std::map<const CStdString, CSoundInfo> soundCache;
-  typedef std::map<int, IAESound*              > actionSoundMap;
+  typedef std::map<int, CAPSounds              > actionSoundMap;
   typedef std::map<int, CWindowSounds          > windowSoundMap;
-  typedef std::map<const CStdString, IAESound* > pythonSoundsMap;
+  typedef std::map<const CStdString, CAPSounds > pythonSoundsMap;
 
   soundCache          m_soundCache;
   actionSoundMap      m_actionSoundMap;
@@ -81,12 +92,13 @@ private:
 
   CStdString          m_strMediaDir;
   bool                m_bEnabled;
+  bool                m_bAudio2;
 
   CCriticalSection    m_cs;
 
-  IAESound* LoadSound(const CStdString &filename);
+  CAPSounds LoadSound(const CStdString &filename);
   void      FreeSound(IAESound *sound);
-  IAESound* LoadWindowSound(TiXmlNode* pWindowNode, const CStdString& strIdentifier);
+  CAPSounds LoadWindowSound(TiXmlNode* pWindowNode, const CStdString& strIdentifier);
 };
 
 extern CGUIAudioManager g_audioManager;
diff --git a/xbmc/settings/GUISettings.cpp b/xbmc/settings/GUISettings.cpp
index 1e4c754..f473877 100644
--- a/xbmc/settings/GUISettings.cpp
+++ b/xbmc/settings/GUISettings.cpp
@@ -530,6 +530,63 @@ void CGUISettings::Initialize()
   AddInt(ao, "audiooutput.guisoundmode", 34120, AE_SOUND_IDLE, guimode, SPIN_CONTROL_TEXT);
 #endif
 
+  //AddSeparator(ao, "audiooutput2.sep0");
+  ao = AddCategory(SETTINGS_SYSTEM, "audiooutput2", 772);
+
+  map<int,int> audiomode2;
+  audiomode2.insert(make_pair(13106,AUDIO_NONE));
+  audiomode2.insert(make_pair(338,AUDIO_ANALOG));
+#if !defined(TARGET_RASPBERRY_PI)
+  audiomode2.insert(make_pair(339,AUDIO_IEC958));
+#endif
+  audiomode2.insert(make_pair(420,AUDIO_HDMI  ));
+#if defined(TARGET_RASPBERRY_PI)
+  AddInt(ao, "audiooutput2.mode", 337, AUDIO_NONE, audiomode2, SPIN_CONTROL_TEXT);
+#else
+  AddInt(ao, "audiooutput2.mode", 337, AUDIO_NONE, audiomode2, SPIN_CONTROL_TEXT);
+#endif
+  
+  AddInt(ao, "audiooutput2.channels", 34100, AE_CH_LAYOUT_2_0, channelLayout, SPIN_CONTROL_TEXT);
+  AddBool(ao, "audiooutput2.normalizelevels", 346, true);
+  AddBool(ao, "audiooutput2.stereoupmix", 252, false);
+  
+#if defined(TARGET_DARWIN_IOS)
+	aocat = g_sysinfo.IsAppleTV2() ? ao : NULL;
+#else
+	aocat = ao;
+#endif
+
+  AddBool(aocat, "audiooutput2.ac3passthrough"   , 364, true);
+  AddBool(aocat, "audiooutput2.dtspassthrough"   , 254, true);
+  
+  
+#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI)
+  AddBool(aocat, "audiooutput2.passthroughaac"   , 299, false);
+#endif
+#if !defined(TARGET_DARWIN_IOS) && !defined(TARGET_RASPBERRY_PI)
+  AddBool(aocat, "audiooutput2.multichannellpcm" , 348, true );
+#endif
+#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI)
+  AddBool(aocat, "audiooutput2.truehdpassthrough", 349, true );
+  AddBool(aocat, "audiooutput2.dtshdpassthrough" , 347, true );
+#endif
+  
+#if !defined(TARGET_RASPBERRY_PI)
+#if defined(TARGET_DARWIN)
+  AddString(ao, "audiooutput2.audiodevice", 545, defaultDeviceName.c_str(), SPIN_CONTROL_TEXT);
+  AddString(NULL, "audiooutput2.passthroughdevice", 546, defaultDeviceName.c_str(), SPIN_CONTROL_TEXT);
+#else
+  AddSeparator(ao, "audiooutput2.sep1");
+  AddString	(ao, "audiooutput2.audiodevice"		, 545, CStdString(CAEFactory::GetDefaultDevice(false,true)), SPIN_CONTROL_TEXT);
+  AddString	(ao, "audiooutput2.passthroughdevice", 546, CStdString(CAEFactory::GetDefaultDevice(true,true)), SPIN_CONTROL_TEXT);
+  AddSeparator(ao, "audiooutput2.sep2");
+#endif
+#endif
+
+#if !defined(TARGET_RASPBERRY_PI)
+  AddInt(ao, "audiooutput2.guisoundmode", 34120, AE_SOUND_IDLE, guimode, SPIN_CONTROL_TEXT);
+#endif
+
   CSettingsCategory* in = AddCategory(SETTINGS_SYSTEM, "input", 14094);
   AddString(in, "input.peripherals", 35000, "", BUTTON_CONTROL_STANDARD);
 #if defined(TARGET_DARWIN)
@@ -1393,6 +1450,25 @@ void CGUISettings::LoadXML(TiXmlElement *pRootElement, bool hideSettings /* = fa
       updated = true;
     }
   }
+  channelNode = pRootElement->FirstChild("audiooutput2");
+  if (channelNode != NULL)
+  {
+    channelNode = channelNode->FirstChild("channellayout");
+    CSettingInt* channels = (CSettingInt*)GetSetting("audiooutput2.channels");
+    if (channelNode != NULL && channelNode->FirstChild() != NULL && channels != NULL)
+    {
+      channels->FromString(channelNode->FirstChild()->ValueStr());
+      if (channels->GetData() < AE_CH_LAYOUT_MAX - 1)
+        channels->SetData(channels->GetData() + 1);
+
+      // let's just reset the audiodevice settings as well
+      std::string audiodevice = GetString("audiooutput2.audiodevice");
+      CAEFactory::VerifyOutputDevice(audiodevice, false);
+      SetString("audiooutput2.audiodevice", audiodevice.c_str());
+
+      updated = true;
+    }
+  }
 
   // and fix the videoscreen.screenmode if necessary
   std::string screenmode = GetString("videoscreen.screenmode");
diff --git a/xbmc/settings/GUISettings.h b/xbmc/settings/GUISettings.h
index 8a343f7..b94840d 100644
--- a/xbmc/settings/GUISettings.h
+++ b/xbmc/settings/GUISettings.h
@@ -81,6 +81,7 @@ class TiXmlElement;
 #define CDDARIP_QUALITY_STANDARD 2
 #define CDDARIP_QUALITY_EXTREME  3
 
+#define AUDIO_NONE        0xF
 #define AUDIO_ANALOG      0
 #define AUDIO_IEC958      1
 #define AUDIO_HDMI        2
diff --git a/xbmc/settings/GUIWindowSettingsCategory.cpp b/xbmc/settings/GUIWindowSettingsCategory.cpp
index cbf0acb..6cda602 100644
--- a/xbmc/settings/GUIWindowSettingsCategory.cpp
+++ b/xbmc/settings/GUIWindowSettingsCategory.cpp
@@ -578,6 +578,18 @@ void CGUIWindowSettingsCategory::CreateSettings()
       FillInAudioDevices(pSetting,true);
       continue;
     }
+    else if (strSetting.Equals("audiooutput2.audiodevice"))
+    {
+      AddSetting(pSetting, group->GetWidth(), iControlID);
+      FillInAudioDevices(pSetting,false,true);
+      continue;
+    }
+    else if (strSetting.Equals("audiooutput2.passthroughdevice"))
+    {
+      AddSetting(pSetting, group->GetWidth(), iControlID);
+      FillInAudioDevices(pSetting,true,true);
+      continue;
+    }
     AddSetting(pSetting, group->GetWidth(), iControlID);
   }
 
@@ -808,6 +820,39 @@ void CGUIWindowSettingsCategory::UpdateSettings()
           pControl->SetEnabled(g_guiSettings.GetInt("audiooutput.mode") == AUDIO_HDMI);
       }
     }
+    else if (
+             strSetting.Equals("audiooutput2.channels") ||
+             strSetting.Equals("audiooutput2.normalizelevels") ||
+             strSetting.Equals("audiooutput2.stereoupmix") ||
+             strSetting.Equals("audiooutput2.audiodevice") ||
+             strSetting.Equals("audiooutput2.guisoundmode"))
+    { // only visible if audioouput2 is used
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(g_guiSettings.GetInt("audiooutput2.mode") != AUDIO_NONE);
+    }
+    else if (
+             strSetting.Equals("audiooutput2.passthroughdevice") ||
+             strSetting.Equals("audiooutput2.ac3passthrough") ||
+             strSetting.Equals("audiooutput2.dtspassthrough") ||
+             strSetting.Equals("audiooutput2.passthroughaac"))
+    { // only visible if we are in digital mode
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl) pControl->SetEnabled(AUDIO_IS_BITSTREAM(g_guiSettings.GetInt("audiooutput2.mode")));
+    }
+    else if (
+             strSetting.Equals("audiooutput2.multichannellpcm" ) ||
+             strSetting.Equals("audiooutput2.truehdpassthrough") ||
+             strSetting.Equals("audiooutput2.dtshdpassthrough" ))
+    {
+      CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
+      if (pControl)
+      {
+        if (strSetting.Equals("audiooutput2.dtshdpassthrough") && !g_guiSettings.GetBool("audiooutput2.dtspassthrough"))
+          pControl->SetEnabled(false);
+        else
+          pControl->SetEnabled(g_guiSettings.GetInt("audiooutput2.mode") == AUDIO_HDMI);
+      }
+    }
     else if (strSetting.Equals("musicplayer.crossfadealbumtracks"))
     {
       CGUIControl *pControl = (CGUIControl *)GetControl(pSettingControl->GetID());
@@ -2032,6 +2077,37 @@ void CGUIWindowSettingsCategory::OnSettingChanged(BaseSettingControlPtr pSetting
 
     CAEFactory::OnSettingsChange(strSetting);
   }
+  else if (strSetting.compare(0, 13, "audiooutput2.") == 0)
+  {
+    if (strSetting.Equals("audiooutput2.audiodevice"))
+    {
+      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+#if defined(TARGET_DARWIN)
+      // save the sinkname - since we don't have sinks on osx
+      // we need to get the fitting sinkname for the device label from the
+      // factory
+      std::string label2sink = pControl->GetCurrentLabel();
+      CAEFactory::VerifyOutputDevice(label2sink, false);
+      g_guiSettings.SetString("audiooutput2.audiodevice", label2sink.c_str());
+#else
+      g_guiSettings.SetString("audiooutput2.audiodevice", m_AnalogAudioSinkMap[pControl->GetCurrentLabel()]);
+#endif
+	  }
+#if !defined(TARGET_DARWIN)
+    else if (strSetting.Equals("audiooutput2.passthroughdevice"))
+    {
+      CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(pSettingControl->GetID());
+      g_guiSettings.SetString("audiooutput2.passthroughdevice", m_DigitalAudioSinkMap[pControl->GetCurrentLabel()]);
+    }
+#endif
+    else if (strSetting.Equals("audiooutput2.guisoundmode"))
+    {
+      CAEFactory::SetSoundMode(g_guiSettings.GetInt("audiooutput2.guisoundmode"),true);
+    }
+  
+    CAEFactory::OnSettingsChange(strSetting,true);
+    g_audioManager.CheckAudio2();
+  }
   else if (strSetting.Equals("pvrparental.enabled"))
   {
     if (g_guiSettings.GetBool("pvrparental.enabled") && g_guiSettings.GetString("pvrparental.pin").GetLength() == 0)
@@ -2951,12 +3027,16 @@ void CGUIWindowSettingsCategory::FillInPvrStartLastChannel(CSetting *pSetting)
   pControl->SetValue(pSettingInt->GetData());
 }
 
-void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough)
+void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Passthrough, bool bAudio2)
 {
   CGUISpinControlEx *pControl = (CGUISpinControlEx *)GetControl(GetSetting(pSetting->GetSetting())->GetID());
   pControl->Clear();
 
-  CStdString currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput.passthroughdevice") : g_guiSettings.GetString("audiooutput.audiodevice");
+  CStdString currentDevice;
+  if(!bAudio2)
+    currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput.passthroughdevice") : g_guiSettings.GetString("audiooutput.audiodevice");
+  else
+    currentDevice = Passthrough ? g_guiSettings.GetString("audiooutput2.passthroughdevice") : g_guiSettings.GetString("audiooutput2.audiodevice");
 
   if (Passthrough)
   {
@@ -2971,7 +3051,7 @@ void CGUIWindowSettingsCategory::FillInAudioDevices(CSetting* pSetting, bool Pas
 
   int selectedValue = -1;
   AEDeviceList sinkList;
-  CAEFactory::EnumerateOutputDevices(sinkList, Passthrough);
+  CAEFactory::EnumerateOutputDevices(sinkList, Passthrough, bAudio2);
 #if !defined(TARGET_DARWIN)
   if (sinkList.size()==0)
   {
diff --git a/xbmc/settings/GUIWindowSettingsCategory.h b/xbmc/settings/GUIWindowSettingsCategory.h
index 0d4649d..629ac1b 100644
--- a/xbmc/settings/GUIWindowSettingsCategory.h
+++ b/xbmc/settings/GUIWindowSettingsCategory.h
@@ -68,7 +68,7 @@ protected:
   void FillInNetworkInterfaces(CSetting *pSetting, float groupWidth, int &iControlID);
   void NetworkInterfaceChanged(void);
 
-  void FillInAudioDevices(CSetting* pSetting, bool Passthrough = false);
+  void FillInAudioDevices(CSetting* pSetting, bool Passthrough = false, bool bAudio2 = false);
 
   virtual void SetupControls();
   CGUIControl* AddIntBasedSpinControl(CSetting *pSetting, float groupWidth, int &iControlID);
